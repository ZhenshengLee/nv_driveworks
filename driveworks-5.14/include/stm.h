/////////////////////////////////////////////////////////////////////////////////////////
//
// Notice
// ALL NVIDIA DESIGN SPECIFICATIONS AND CODE ("MATERIALS") ARE PROVIDED "AS IS" NVIDIA MAKES
// NO REPRESENTATIONS, WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
//
// NVIDIA CORPORATION & AFFILIATES assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA CORPORATION & AFFILIATES. No third party distribution is allowed unless
// expressly authorized by NVIDIA. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA CORPORATION & AFFILIATES products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA CORPORATION & AFFILIATES.
//
// SPDX-FileCopyrightText: Copyright (c) 2018-2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: LicenseRef-NvidiaProprietary
//
// NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
// property and proprietary rights in and to this material, related
// documentation and any modifications thereto. Any use, reproduction,
// disclosure or distribution of this material and related documentation
// without an express license agreement from NVIDIA CORPORATION or
// its affiliates is strictly prohibited.
//
/////////////////////////////////////////////////////////////////////////////////////////

/**
 * @file stm.h
 *
 * @brief STM Runtime
 *
 * Overview:
 * STM is a co-operative, non-preemptive, static scheduling framework for real-time systems.
 * The STM runtime is a library that executes a schedule produced offline by the STM compiler, enforcing
 * data dependency ordering and control flow ordering across engines on a Tegra SoC.
 *
 * STM Clients:
 * Every STM client corresponds to an OS process. All STM clients mentioned to the STM compiler must be launched before
 * any STM client will begin scheduling runnables.
 *
 * STM Master:
 * Alongside STM clients, the STM master executable needs to be launched and passed a .stm file generated by the
 * STM compiler. STM clients will block at the call to stmClientInit() until the STM master process has been launched.
 **/

#ifndef STM_H_
#define STM_H_

#if __GNUC__ >= 4
#define STM_API __attribute__((visibility("default")))
#endif

#include <stdint.h>
#include "stm_error.h"
#include <cuda_runtime.h>
#include <stdbool.h>

#ifdef VIBRANTE
#if VIBRANTE_PDK_DECIMAL < 6000400
#include <nvmedia_dla.h>
#endif
#if VIBRANTE_PDK_DECIMAL >= 6000000
#include <cupva_host_wrapper.h>
#if VIBRANTE_PDK_DECIMAL >= 6000500
#include <VulkanSC/vulkan/vulkan_sc.h>
#endif
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Information which can be queried by CPU runnables using stmGetRuntimeInfo()
 */
typedef struct
{
    uint32_t epochIterations;
    uint16_t scheduleId;
} stmRunnableInfo_t;

/**
 * @brief Function signature for STM CPU runnable.
 *
 * @remark stmRunnable_t functions should only contain CPU work. They should not call any blocking APIs or internally
 * launch any threads.
 */
typedef void (*stmRunnable_t)(void* userdata);

/**
 * @brief Function signature for STM CUDA submitter runnable.
 *
 * @remark stmCudaSubmitter_t functions should contain some CPU work, followed by some number of asynchronous
 * CUDA kernel launches. All kernels launched in submitter must be launched onto cudaStream_t stream. The use of stream 0
 * (the null stream) is prohibited due to CUDA's implicit synchronization semantics. This function should not internally
 * launch any threads or call any blocking APIs, including cudaMemcpy(), cudaMemset(), cudaFree(), etc..
 *
 * @param[in] userdata Pointer to any data needed by the runnable
 * @param[in] stream CUDA stream created by application for the kernels
 */
typedef void (*stmCudaSubmitter_t)(void* userdata, cudaStream_t stream);

/** @brief Initialize STM client context.
 *
 *  @remark This API must be called before any other STM APIs. This API will block until the STM master process is started.
 *  Client contexts should be cleaned up with stmClientExit() after STM has completed its execution.
 *  Same as calling stmClientInitWithDiscriminator() with \p discriminator = -1
 */
STM_API void stmClientInit(const char* clientName);

/** @brief Initialize STM client context with a discriminator.
 *
 *  @remark This API must be called before any other STM APIs. This API will block until the STM master process with this \p discriminator is started.
 *  Client contexts should be cleaned up with stmClientExit() after STM has completed its execution.
 *  Client must call at most one of the two: stmClientInit() or stmClientInitWithDiscriminator()
 *  All negative values of \p discriminator are equivalent and the same as calling stmClientInit()
 */
STM_API void stmClientInitWithDiscriminator(const char* clientName, int32_t discriminator);

/** @brief Registers an stmRunnable_t function with the name provided by the user to the STM compiler.
 *
 *  @param[in] func STM CPU runnable function pointer.
 *  @param[in] runnableId Name of CPU runnable provided to the STM compiler.
 *  @param[in] userdata Pointer to any data needed by the runnable.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterCpuRunnable(stmRunnable_t func, const char* const runnableId, void* userdata);

/** @brief Registers an stmCudaSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  @param[in] func STM CUDA submitter runnable function pointer.
 *  @param[in] runnableId Name of CUDA submitter runnable provided to the STM compiler.
 *  @param[in] userdata Pointer to any data needed by the runnable.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterCudaSubmitter(stmCudaSubmitter_t func, const char* const runnableId, void* userdata);

/** @brief Registers a CUDA stream resource.
 *
 *  @param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  @param[in] stream CUDA stream created by application.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if any of the following occurs:
 *      - resourceName exceeds STM_RESOURCE_NAME_MAX
 *      - the number of resources registered exceeds STM_MAX_NUM_RESOURCES
 *      - stream is the NULL stream or has not been previously created by calling cudaStreamCreate()
 *      - the same cudaStream_t has already been registered (possibly with a different resourceName)
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterCudaResource(const char* resourceName, cudaStream_t stream);

#ifdef VIBRANTE

#if VIBRANTE_PDK_DECIMAL >= 6000500
STM_API stmErrorCode_t stmRegisterVulkanResource(const char* resourceName, VkQueue queue, VkDevice device, VkPhysicalDevice physicalDevice, VkInstance instance);

typedef void (*stmVulkanSubmitter_t)(void* userdata, VkQueue queue);

STM_API stmErrorCode_t stmRegisterVulkanSubmitter(stmVulkanSubmitter_t func, const char* const runnableId, void* userdata);
#endif

#if VIBRANTE_PDK_DECIMAL < 6000400
/**
 * @brief Function signature for STM DLA submitter runnable.
 *
 * @remark stmDlaSubmitter_t functions should contain some CPU work, followed by some number of NvMediaDla submits. All
 * submits must be launched on the provided NvMediaDla handle. These functions should not internally launch any threads
 * or call any blocking APIs.
 *
 * @param[in] userdata Pointer to any data needed by the runnable
 * @param[in] dla DLA handle created by application
 */
typedef void (*stmDlaSubmitter_t)(void* userdata, NvMediaDla* dla);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000200
/**
 * @brief Function signature for STM cuDLA submitter runnable.
 *
 * @remark stmCuDlaSubmitter_t functions should contain some CPU work, followed by some number of cuDLA submits.
 * All submits must be launched on the provided cuDLA handle. These functions should not internally launch
 * any threads or call any blocking APIs. STM cuDLA Support is only enabled with the 6.0.2.0 PDK, and will fail at the link
 * stage otherwise.
 *
 * @param[in] userdata Pointer to any data needed by the runnable
 * @param[in] cudla CUDA stream created by application
 */
typedef void (*stmCuDlaSubmitter_t)(void* userdata, cudaStream_t cudla);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000000
/**
 * @brief Function signature for STM VPU submitter runnable.
 *
 * @remark stmVpuSubmitter_t functions should contain some CPU work, followed by some number of VPU submits.
 * All submits must be launched on the provided cuPVA stream. These functions should not internally launch
 * any threads or call any blocking APIs. STM VPU Support is only enabled with the 6.0.0.0 PDK, and will fail at the link
 * stage otherwise.
 *
 * @param[in] userdata Pointer to any data needed by the runnable
 * @param[in] vpu cuPVA stream created by application
 */
typedef void (*stmVpuSubmitter_t)(void* userdata, cupvaStream_t vpu);
#endif

#if VIBRANTE_PDK_DECIMAL < 6000400
/**
 * @brief Registers a NvMediaDla resource.
 *
 *  @param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  @param[in] dla DLA stream created by application.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if any of the following occurs:
 *      - resourceName exceeds STM_RESOURCE_NAME_MAX
 *      - the number of resources registered exceeds STM_MAX_NUM_RESOURCES
 *      - dla is NULL or has not been previously created by calling NvMediaDlaCreate()
 *      - the same NvMediaDla handle has already been registered (possibly with a different resourceName)
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterDlaResource(const char* resourceName, NvMediaDla* dla);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000200
/**
 * @brief Registers a cuDLA resource.
 *
 *  @remark STM cuDLA Support is only enabled with the 6.0.2.0 PDK, and will fail at the link stage otherwise.
 *
 *  @param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  @param[in] cudla The CUDA stream created by the application used for cuDLA task submission
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if any of the following occurs:
 *      - resourceName exceeds STM_RESOURCE_NAME_MAX
 *      - the number of resources registered exceeds STM_MAX_NUM_RESOURCES
 *      - cudla is NULL or has not been previously created by calling cudaStreamCreate()
 *      - the same CUDA stream has already been registered (possibly with a different resourceName)
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterCuDlaResource(const char* resourceName, cudaStream_t cudla);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000000
/**
 * @brief Registers a cuPVA resource.
 *
 *  @remark STM cuPVA Support is only enabled with the 6.0.0.0 PDK, and will fail at the link stage otherwise.
 *
 *  @param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  @param[in] vpu cuPVA stream created by application.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if any of the following occurs:
 *      - resourceName exceeds STM_RESOURCE_NAME_MAX
 *      - the number of resources registered exceeds STM_MAX_NUM_RESOURCES
 *      - vpu is NULL or has not been previously created by calling cupvaStreamCreate()
 *      - the same cuPVA stream has already been registered (possibly with a different resourceName)
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterVpuResource(const char* resourceName, cupvaStream_t vpu);
#endif

#if VIBRANTE_PDK_DECIMAL < 6000400
/**
 * @brief Registers an stmDlaSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  @param[in] func STM DLA submitter runnable function pointer.
 *  @param[in] runnableId Name of DLA submitter runnable provided to the STM compiler.
 *  @param[in] userdata Pointer to any data needed by the runnable.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterDlaSubmitter(stmDlaSubmitter_t func, const char* const runnableId, void* userdata);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000200
/**
 * @brief Registers an stmCudlaSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  @remark STM cuDLA Support is only enabled with the 6.0.2.0 PDK, and will fail at the link stage otherwise.
 *
 *  @param[in] func STM cuDLA submitter runnable function pointer.
 *  @param[in] runnableId Name of cuDLA submitter runnable provided to the STM compiler.
 *  @param[in] userdata Pointer to any data needed by the runnable.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterCuDlaSubmitter(stmCuDlaSubmitter_t func, const char* const runnableId, void* userdata);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000000
/**
 * @brief Registers an stmVpuSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  @remark STM cuPVA Support is only enabled with the 6.0.0.0 PDK, and will fail at the link stage otherwise.
 *
 *  @param[in] func STM cuPVA submitter runnable function pointer.
 *  @param[in] runnableId Name of cuPVA submitter runnable provided to the STM compiler.
 *  @param[in] userdata Pointer to any data needed by the runnable.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterVpuSubmitter(stmVpuSubmitter_t func, const char* const runnableId, void* userdata);
#endif

#endif

/**
 * @brief Function signature for STM schedule switch callback.
 *
 * @remark stmScheduleSwitchCallback_t functions should only contain some CPU work.
 * This function will be called once per hyperepoch for each client.
 */
typedef void (*stmScheduleSwitchCallback_t)(uint16_t startScheduleId, uint16_t hyperepochId, void* userdata);

/**
 * @brief Registers a callback function with a client to be invoked during a schedule switch. Before this client
 * starts running, the callback function will be invoked.
 *
 * @remark This API can only be called once per client; doing so multiple times will result in an error.
 *
 * @param[in] func The callback function to be executed.
 * @param[in] userdata Optional pointer to any data needed by the callback.
 *
 * @return stmErrorCode_t, the completion code of the operation:
 * - STM_ERROR_BAD_PARAMETER if a call back function has already been registered with this client.
 * - STM_SUCCESS
 */
STM_API stmErrorCode_t stmRegisterCallBack(stmScheduleSwitchCallback_t func, void* userdata);

/** @brief Yield to STM scheduler, which will schedule all registered runnables in the STM schedule periodically until
 * completion. This function will not return until a runnable calls stmExitScheduler() or the number of epochs specified
 * in the STM master process have completed.
 *
 *  @remark All runnables and resources need to be registered prior to entering the schedule. This API will only begin
 * scheduling work after all STM clients have started. This API can only be called once per call to stmClientInit();
 * doing so multiple times will cause undefined behavior.
 *
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_TIMEOUT if any fence timed out.
 *  - STM_ERROR_GENERIC if there was another error.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmEnterScheduler(void);

/** @brief Get runtime information about execution
 *
 *  @remark Must be called from within a CPU runnable
 *
 *  @param[out] info Pointer to stmRunnableInfo_t whose fields will be populated
 *
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if info is NULL.
 *  - STM_ERROR_NOT_FOUND if the current STM thread could not be found.
 *  - STM_ERROR_INVALID_STATE if the requisite information could not be obtained.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmGetRuntimeInfo(stmRunnableInfo_t* info);

/** @brief Return from stmEnterScheduler().
 *
 *  @remark Called from within a runnable; causes all clients to return from their respective calls to stmEnterScheduler()
 *  at the next epoch boundary. Only needs to be called from one runnable in one STM client; subsequent calls are ignored.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  -STM_SUCCESS if successful.
 *  -STM_ERROR_GENERIC if the request to set the state to exit failed.
 *  -STM_ERROR_BAD_PARAMETER if the request to set the state to exit has already been triggered.
 *  -STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmExitScheduler(void);

/**
 * @brief Cleans up STM client context. No STM APIs can be called after this.
 *
 * @remark This API can only be called once per call to stmClientInit(); doing so multiple times will cause undefined  behavior.
 **/
STM_API void stmClientExit(void);

#ifdef __cplusplus
}
#endif

#endif
