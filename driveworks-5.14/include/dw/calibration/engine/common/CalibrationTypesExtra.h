////////////////////////////////////////////////////////////////////////////////
// This code contains NVIDIA Confidential Information and is disclosed
// under the Mutual Non-Disclosure Agreement.
//
// Notice
// ALL NVIDIA DESIGN SPECIFICATIONS AND CODE ("MATERIALS") ARE PROVIDED "AS IS"
// NVIDIA MAKES NO REPRESENTATIONS, WARRANTIES, EXPRESSED, IMPLIED, STATUTORY,
// OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ANY
// IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// NVIDIA Corporation assumes no responsibility for the consequences of use of
// such information or for any infringement of patents or other rights of third
// parties that may result from its use. No license is granted by implication or
// otherwise under any patent or patent rights of NVIDIA Corporation. No third
// party distribution is allowed unless expressly authorized by NVIDIA.  Details
// are subject to change without notice. This code supersedes and replaces all
// information previously supplied. NVIDIA Corporation products are not
// authorized for use as critical components in life support devices or systems
// without express written approval of NVIDIA Corporation.
//
// Copyright (c) 2016-2023 NVIDIA Corporation. All rights reserved.
//
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and any
// modifications thereto. Any use, reproduction, disclosure or distribution of
// this software and related documentation without an express license agreement
// from NVIDIA Corporation is strictly prohibited.
//
////////////////////////////////////////////////////////////////////////////////
#ifndef DW_CALIBRATION_ENGINE_COMMON_CALIBRATIONTYPESEXTRA_H_
#define DW_CALIBRATION_ENGINE_COMMON_CALIBRATIONTYPESEXTRA_H_
// Generated by dwProto from calibration_types_extra.proto DO NOT EDIT BY HAND!
// See //3rdparty/shared/dwproto/README.md for more information

//WARNING!!!
// Please don't use any type definition in this file.
// All of data types in this file are going to be modified and will not
// follow Nvidia deprecation policy.

/**
 * @file
 * <b>NVIDIA DriveWorks API: Calibration</b>
 *
 * @b Description: Contains extra types associated with Calibration
 */

#include <dw/core/base/Types.h>

#include <dw/calibration/engine/common/CalibrationBaseTypes.h>
#include <dw/core/base/TypesExtra.h>

#ifdef __cplusplus
extern "C" {
#endif

#define DW_CALIBRATION_PASS_COUNT_CAMERA 2
#define DW_CALIBRATION_PASS_COUNT_LIDAR 2
/// Represents a collection of calibration maneuvers
#define DW_CALIBRATION_MANEUVER_MAX_ARRAY_SIZE 3

/// @brief Defines all computation pass variants that can be triggered with `dwCalibrationEngine_executePass`
/// @note GPU pass variants are guaranteed to execute work on the GPU asynchronously, while CPU pass variants
///       generally synchronize their execution with their preceeding GPU pass
typedef enum dwCalibrationPass {
    /// Computation passes of routines initialized with `dwCalibrationEngine_initializeCamera`
    DW_CALIBRATION_PASS_CAMERA_GPU0_ASYNC = 0,
    DW_CALIBRATION_PASS_CAMERA_CPU0_SYNC  = 1,

    /// Computation passes of routines initialized with `dwCalibrationEngine_initializeLidar`
    DW_CALIBRATION_PASS_LIDAR_GPU0_ASYNC = 2,
    DW_CALIBRATION_PASS_LIDAR_CPU0_SYNC  = 3,
    DW_CALIBRATION_PASS_COUNT            = 4,
    DW_CALIBRATION_PASS_FORCE32          = 0x7fffffff,
} dwCalibrationPass;

/// @brief Driving Maneuvers
///
/// Defines different calibration-specific driving maneuvers (expected motions and motion properties) that
/// can assist operators to perform the remaining maneuvers to support calibration routines
/// to make estimation progress.
///
/// @brief Enumeration of different motion types of a calibration maneuver
typedef enum dwCalibrationManeuverMotionType {
    DW_CALIBRATION_MANEUVER_MOTIONTYPE_UNSPECIFIED        = 0,
    DW_CALIBRATION_MANEUVER_MOTIONTYPE_FORWARD            = 1,
    DW_CALIBRATION_MANEUVER_MOTIONTYPE_ANY_TURN           = 2,
    DW_CALIBRATION_MANEUVER_MOTIONTYPE_STOP               = 3,
    DW_CALIBRATION_MANEUVER_MOTIONTYPE_FORWARD_AFTER_STOP = 4,
    DW_CALIBRATION_MANEUVER_MOTIONTYPE_COUNT              = 5,
    DW_CALIBRATION_MANEUVER_MOTIONTYPE_FORCE32            = 0x7fffffff,
} dwCalibrationManeuverMotionType;

/// @brief Enumeration of different variant types of a calibration property
typedef enum dwCalibrationPropertiesVariantType {
    DW_CALIBRATION_PROPERTY_VARIANT_UNKNOWN         = 0,
    DW_CALIBRATION_PROPERTY_VARIANT_REGULAR         = 1, //!< no special self-calibration condition applies
    DW_CALIBRATION_PROPERTY_VARIANT_FAST_ACCEPTANCE = 2, //!< self-calibration was initialized with previously-accepted value and is running in "fast-acceptance" mode
    DW_CALIBRATION_PROPERTY_VARIANT_BOOTSTRAPPED    = 3, //!< calibration values are initialized with previously-accepted value, but self-calibration is *not* running
    DW_CALIBRATION_PROPERTY_VARIANT_FORCE32         = 0x7fffffff,
} dwCalibrationPropertiesVariantType;

/// @brief Enumeration of different initialization types of a calibration property
typedef enum dwCalibrationPropertiesInitializationType {
    DW_CALIBRATION_PROPERTY_INITIALIZATION_UNKNOWN             = 0,
    DW_CALIBRATION_PROPERTY_INITIALIZATION_PREVIOUSLY_ACCEPTED = 1, //!< calibration was initialized with previously-accepted values
    DW_CALIBRATION_PROPERTY_INITIALIZATION_FORCE32             = 0x7fffffff,
} dwCalibrationPropertiesInitializationType;

/// @brief Defines the possible sensor position states
typedef enum dwCalibrationSensorPositionState {
    /// The sensor is located at the fixed position
    DW_CALIBRATION_SENSOR_POSITION_DEFAULT = 0,

    /// The camera is located on an unfolded mirror
    DW_CALIBRATION_CAMERA_POSITION_MIRROR_UNFOLDED = 1,

    /// The camera is located on a folded mirror
    DW_CALIBRATION_CAMERA_POSITION_MIRROR_FOLDED = 2,

    /// The camera is located on a front grill (outer position)
    DW_CALIBRATION_CAMERA_POSITION_FRONT_GRILL_UNFOLDED = 3,

    /// The camera is located on a front grill (inner position)
    DW_CALIBRATION_CAMERA_POSITION_FRONT_GRILL_FOLDED = 4,

    /// The camera is located on a trunk logo (unfolded position)
    DW_CALIBRATION_CAMERA_POSITION_REAR_TRUNK_UNFOLDED = 5,

    /// The camera is located on a trunk logo (folded position, a camera is hidden behind the logo)
    DW_CALIBRATION_CAMERA_POSITION_REAR_TRUNK_FOLDED = 6,

    /// The camera location is invalid (while camera movement or hidden cameras or when open a door with a camera is open)
    DW_CALIBRATION_CAMERA_POSITION_IN_TRANSITION = 7,
    DW_CALIBRATION_CAMERA_POSITION_FORCE32       = 0x7fffffff,
} dwCalibrationSensorPositionState;

/// @brief Parameters for histogram estimators
typedef struct dwCalibrationHistogramEstimatorParameters
{
    /// Min/Max range for correction values [-correctionRange, correctionRange] around zero (signal units)
    float32_t correctionRange;

    /// The distance between histogram bins (signal units)
    float32_t correctionAccuracy;

    /// The minimum number of samples in the histogram peak bin required for acceptance
    float32_t acceptanceMinSampleCount;

    /// The number of samples in a bin that will be discarded as noise
    float32_t acceptanceNoiseSampleCount;

    /// The width of the envelope function used to determine acceptance (signal units)
    float32_t acceptanceSigma;

    /// Samples outside [-failureOutlierRange, failureOutlierRange] will be considered as outliers (signal units)
    float32_t failureOutlierRange;

    /// The maximum number of recent outliers not in the histogram limits that will trigger a failure of the estimation
    uint32_t failureMaxOutlierCount;

    /// Smoothing sigma for histogram low-pass filtering (signal units)
    float32_t smoothingSigma;

    /// Decay rate for the long term decay histogram (unitless)
    float32_t decayRate;

    /// Factor applied to long-term decay rate to obtain short term decay rate (unitless, should be < 1, FastAcceptanceRejectionEstimator only)
    float32_t shortTermScale;

    /// Factor for all envelopes used to scale envelope max value relative to histogram max value (unitless, should be > 1, FastAcceptanceRejectionEstimator only)
    float32_t amplitudeScaleFactor;

    /// Factor applied to acceptanceSigma for short-term envelope (unitless, FastAcceptanceRejectionEstimator only)
    float32_t shortSigmaFactor;

    /// Factor applied to acceptanceSigma for rejection envelope (unitless, FastAcceptanceRejectionEstimator only)
    float32_t rejectionSigmaFactor;

    /// The minimum number of samples in the short-term histogram peak bin to consider it for fast-acceptance (FastAcceptanceRejectionEstimator only)
    float32_t fastAcceptanceMinSampleCount;

    /// Fast acceptance +/- *value* envelope around reference that is being fast-accepted (signal units, FastAcceptanceRejectionEstimator only)
    float32_t fastAcceptanceThreshold;
} dwCalibrationHistogramEstimatorParameters;

/// @brief  Parameters for calibrating the odometry properties
typedef struct dwCalibrationOdometryPropertiesParameters
{
    /// speed factor estimator settings
    dwCalibrationHistogramEstimatorParameters speedFactorEstimator;

    /// wheel radii estimator settings
    dwCalibrationHistogramEstimatorParameters wheelRadiiEstimator;

    /// minimal speed below which we ignore any samples (at least 1m/s, default 1m/s)
    float32_t minimalSpeed;

    /// maximal steering angle above which we ignore any samples (default 3deg)
    float32_t maximalSteering;
} dwCalibrationOdometryPropertiesParameters;

/// @brief Definition of a single maneuver's expected motion and optional motion properties
typedef struct dwCalibrationManeuverMotion
{
    dwCalibrationManeuverMotionType type;             //!< represents the expected motion type of the maneuver
    dwOptionalf targetDurationSec;                    //!< if valid, represents the expected maneuver duration (in seconds)
    dwOptionalf targetSpeedMeterPerSec;               //!< if valid, represents the expected motion speed (meters per second)
    dwOptionalf targetAccelerationMeterPerSecSquared; //!< if valid, represents the expected motion acceleration (meters per second^2)
} dwCalibrationManeuverMotion;

/// @brief  Struct to collect all status information associated with a maneuver
typedef struct dwCalibrationManeuverStatus
{
    bool fulfilled; //!< if false, the associated maneuver's motion is still required for a routine to complete its estimation
} dwCalibrationManeuverStatus;

/// @brief Aggregation struct of a calibration maneuver motion description together with its current runtime status properties inferred from a calibration routine
typedef struct dwCalibrationManeuver
{
    dwCalibrationManeuverMotion motion; // the motion of the maneuver
    dwCalibrationManeuverStatus status; // the status of the maneuver
} dwCalibrationManeuver;

/// @brief Struct to represent a collection of calibration maneuvers
typedef struct dwCalibrationManeuverArray
{
    dwCalibrationManeuver maneuvers[DW_CALIBRATION_MANEUVER_MAX_ARRAY_SIZE]; // the different maneuvers of the collection
    size_t size;                                                             //!< number of maneuvers present in the array
} dwCalibrationManeuverArray;

/// @brief Definition of static calibration properties
typedef struct dwCalibrationProperties
{
    dwCalibrationPropertiesVariantType variant;
    dwCalibrationPropertiesInitializationType initialization;
} dwCalibrationProperties;

/// @brief Defines the calibrated IMU intrinsics.
typedef struct dwCalibratedIMUIntrinsics
{
    dwVector3f gyroscopeBias;
    dwVector3f accelerometerBias;

    /// Calibration status for accelerometer bias calibration.
    dwCalibrationStatus status;

    /// Calibration properties for accelerometer bias calibration.
    dwCalibrationProperties properties;

    /// Required calibration maneuvers for accelerometer bias calibration.
    dwCalibrationManeuverArray maneuvers;
    uint32_t sensorID;
    bool validGyroscopeBias;
    bool validAccelerometerBias;
    dwTime_t timestamp;
} dwCalibratedIMUIntrinsics;

#ifdef __cplusplus
}
#endif

#endif // DW_CALIBRATION_ENGINE_COMMON_CALIBRATIONTYPESEXTRA_H_
