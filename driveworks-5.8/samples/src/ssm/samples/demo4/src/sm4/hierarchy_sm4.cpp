/////////////////////////////////////////////////////////////////////////////////////////
//
// Notice
// ALL NVIDIA DESIGN SPECIFICATIONS AND CODE ("MATERIALS") ARE PROVIDED "AS IS" NVIDIA MAKES
// NO REPRESENTATIONS, WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
//
// NVIDIA CORPORATION & AFFILIATES assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA CORPORATION & AFFILIATES. No third party distribution is allowed unless
// expressly authorized by NVIDIA. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA CORPORATION & AFFILIATES products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA CORPORATION & AFFILIATES.
//
// SPDX-FileCopyrightText: Copyright (c) 2016-2021 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: LicenseRef-NvidiaProprietary
//
// NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
// property and proprietary rights in and to this material, related
// documentation and any modifications thereto. Any use, reproduction,
// disclosure or distribution of this material and related documentation
// without an express license agreement from NVIDIA CORPORATION or
// its affiliates is strictly prohibited.
//
// Parser Version: 0.7.5
// SSM Version:    0.9.1
//
/////////////////////////////////////////////////////////////////////////////////////////

/**
* The following file has been generated by SSM's parser.
* Please do not manually modify the files
*/

#include <ssm/StateMachine.hpp>

namespace SystemStateManager
{

namespace SM4
{

static std::atomic<bool> showHeadSpecs {true};

static std::mutex showHeadSpecsLock;

bool setupHierarchy(StateMachineVector &stateMachineVector, StateMachinePtr &headPtr)
{
    int smStartPort = 0;
    int cloneStartPort = 0;
    SWCVector swcVector;

    std::string startPort = getKeyFromMasterQAFile("startport");
    if (startPort != "")
    {
        overrideBasePort = std::stoi(startPort);
        setPorts();
    }
    std::string remoteSSMIP = getKeyFromMasterQAFile("remoteSSMIP");
    if (remoteSSMIP != "")
    {
        ssmMasterIPAddr = remoteSSMIP;
    }

    smStartPort = startSocketPort;
    cloneStartPort = smStartPort + MAX_SMs_ALLOWED;
    StateMachinePtr SSM_sm = StateMachinePtr(new StateMachine("SSM", ssmMasterIPAddr.c_str(), smStartPort++, true));
    StateMachinePtr SM2_sm = StateMachinePtr(new StateMachine("SM2", ssmMasterIPAddr.c_str(), smStartPort++, true));
    StateMachinePtr SM22_sm = StateMachinePtr(new StateMachine("SM22", ssmMasterIPAddr.c_str(), smStartPort++, true));
    StateMachinePtr SM1_sm = StateMachinePtr(new StateMachine("SM1", ssmMasterIPAddr.c_str(), smStartPort++, true));
    SSM_sm->addStates({"Degrade", "NormalOperation", "Standby", "UrgentOperation"});
    SSM_sm->finalizeStates();

    if (!SSM_sm->addTransition("Degrade", "UrgentOperation")) return false;
    if (!SSM_sm->addTransition("NormalOperation", "Degrade")) return false;
    if (!SSM_sm->addTransition("NormalOperation", "UrgentOperation")) return false;
    if (!SSM_sm->addTransition("Standby", "NormalOperation")) return false;
    if (!SSM_sm->addTransition("UrgentOperation", "Standby")) return false;
    if (!SSM_sm->setStartState("Standby")) return false;

    SM2_sm->addStates({"A2", "B2", "C2", "D2"});
    SM2_sm->finalizeStates();

    if (!SM2_sm->addTransition("A2", "B2")) return false;
    if (!SM2_sm->addTransition("B2", "C2")) return false;
    if (!SM2_sm->addTransition("C2", "D2")) return false;
    if (!SM2_sm->addTransition("D2", "A2")) return false;
    if (!SM2_sm->setStartState("A2")) return false;

    SM22_sm->addStates({"A22", "B22", "C22", "D22"});
    SM22_sm->finalizeStates();

    if (!SM22_sm->addTransition("A22", "B22")) return false;
    if (!SM22_sm->addTransition("B22", "C22")) return false;
    if (!SM22_sm->addTransition("C22", "D22")) return false;
    if (!SM22_sm->addTransition("D22", "A22")) return false;
    if (!SM22_sm->setStartState("A22")) return false;

    SM1_sm->addStates({"A1", "B1", "C1", "D1"});
    SM1_sm->finalizeStates();

    if (!SM1_sm->addTransition("A1", "B1")) return false;
    if (!SM1_sm->addTransition("B1", "C1")) return false;
    if (!SM1_sm->addTransition("C1", "D1")) return false;
    if (!SM1_sm->addTransition("D1", "A1")) return false;
    if (!SM1_sm->setStartState("A1")) return false;

    if (!SSM_sm->addChild("Standby", SM1_sm)) return false;
    if (!SSM_sm->addChild("NormalOperation", SM2_sm)) return false;
    if (!SSM_sm->addChild("Degrade", SM1_sm)) return false;
    if (!SSM_sm->addChild("UrgentOperation", SM2_sm)) return false;

    if (!SM2_sm->addChild("A2", SM22_sm)) return false;
    if (!SM2_sm->addChild("B2", SM22_sm)) return false;
    if (!SM2_sm->addChild("C2", SM22_sm)) return false;
    if (!SM2_sm->addChild("D2", SM22_sm)) return false;

    stateMachineVector.push_back(SSM_sm);
    stateMachineVector.push_back(SM2_sm);
    stateMachineVector.push_back(SM22_sm);
    stateMachineVector.push_back(SM1_sm);
    SSM_sm->setIgnoreClonesFile("/tmp/ignore_swc_list.txt");
    SSM_sm->setSWCClonesListFile("/tmp/swc_list.txt");
    SSM_sm->addClones(swcVector, stateMachineVector, cloneStartPort);

    headPtr = SSM_sm;

    ////////// CRITICAL SECTION //////////////
    SSMLock lg(showHeadSpecsLock);
    if (showHeadSpecs) {
        showHeadSpecs = false;
        SSM_LOG("Setup Hierarchy for SM4");
        headPtr->logStateMachineSpecs();
    }
    /////////////////////////////////////////
    finalMaxPort = smStartPort > finalMaxPort ? smStartPort : finalMaxPort;
    finalMaxPort = cloneStartPort > finalMaxPort ? cloneStartPort : finalMaxPort;
    return true;
}}
}
