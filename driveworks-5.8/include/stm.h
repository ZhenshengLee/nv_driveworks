/////////////////////////////////////////////////////////////////////////////////////////
//
// Notice
// ALL NVIDIA DESIGN SPECIFICATIONS AND CODE ("MATERIALS") ARE PROVIDED "AS IS" NVIDIA MAKES
// NO REPRESENTATIONS, WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
//
// NVIDIA CORPORATION & AFFILIATES assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA CORPORATION & AFFILIATES. No third party distribution is allowed unless
// expressly authorized by NVIDIA. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA CORPORATION & AFFILIATES products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA CORPORATION & AFFILIATES.
//
// SPDX-FileCopyrightText: Copyright (c) 2018-2022 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: LicenseRef-NvidiaProprietary
//
// NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
// property and proprietary rights in and to this material, related
// documentation and any modifications thereto. Any use, reproduction,
// disclosure or distribution of this material and related documentation
// without an express license agreement from NVIDIA CORPORATION or
// its affiliates is strictly prohibited.
//
/////////////////////////////////////////////////////////////////////////////////////////

/**
 * \file stm.h
 *
 * \brief STM Runtime
 *
 * Overview:
 * STM is a co-operative, non-preemptive, static scheduling framework for real-time systems.
 * The STM runtime is a library that executes a schedule produced offline by the STM compiler, enforcing
 * data dependency ordering and control flow ordering across engines on a Tegra SoC.
 *
 * STM Clients:
 * Every STM client corresponds to an OS process. All STM clients mentioned to the STM compiler must be launched before
 * any STM client will begin scheduling runnables.
 *
 * STM Master:
 * Alongside STM clients, the STM master executable needs to be launched and passed a .stm file generated by the
 * STM compiler. STM clients will block at the call to stmClientInit() until the STM master process has been launched.
 **/

#ifndef STM_H_
#define STM_H_

#if __GNUC__ >= 4
#define STM_API __attribute__((visibility("default")))
#endif

#include <stdint.h>
#include "stm_error.h"
#include <cuda_runtime.h>
#include <stdbool.h>

#ifdef VIBRANTE
#if VIBRANTE_PDK_DECIMAL < 6000400
#include <nvmedia_dla.h>
#endif
#if VIBRANTE_PDK_DECIMAL >= 6000400
#include <cupva_host_wrapper.h>
#endif

#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * \brief Information which can be queried by CPU runnables using stmGetRuntimeInfo()
 */
typedef struct
{
    uint32_t epochIterations;
    uint16_t scheduleId;
} stmRunnableInfo_t;

/**
 * \brief Function signature for STM CPU runnable.
 *
 * \remark stmRunnable_t functions should only contain CPU work. They should not call any blocking APIs or internally
 * launch any threads.
 */
typedef void (*stmRunnable_t)(void* userdata);

/**
 * \brief Function signature for STM CUDA submitter runnable.
 *
 * \remark stmCudaSubmitter_t functions should contain some CPU work, followed by some number of asynchronous
 * CUDA kernel launches. All kernels launched in submitter must be launched onto cudaStream_t stream. The use of stream 0
 * (the null stream) is prohibited due to CUDA's implicit synchronization semantics. This function should not internally
 * launch any threads or call any blocking APIs, including cudaMemcpy(), cudaMemset(), cudaFree(), etc..
 */
typedef void (*stmCudaSubmitter_t)(void* userdata, cudaStream_t stream);

/** \brief Initialize STM client context.
 *
 *  \remark This API must be called before any other STM APIs. This API will block until the STM master process is started.
 *  Client contexts should be cleaned up with stmClientExit() after STM has completed its execution.
 *  Same as calling stmClientInitWithDiscriminator() with \p discriminator = -1
 */
STM_API void stmClientInit(const char* clientName);

/** \brief Initialize STM client context with a discriminator.
 *
 *  \remark This API must be called before any other STM APIs. This API will block until the STM master process with this \p discriminator is started.
 *  Client contexts should be cleaned up with stmClientExit() after STM has completed its execution.
 *  Client must call at most one of the two: stmClientInit() or stmClientInitWithDiscriminator()
 *  All negative values of \p discriminator are equivalent and the same as calling stmClientInit()
 */
STM_API void stmClientInitWithDiscriminator(const char* clientName, int32_t discriminator);

/** \brief Registers an stmRunnable_t function with the name provided by the user to the STM compiler.
 *
 *  \param[in] func STM CPU runnable function pointer.
 *  \param[in] runnableId Name of CPU runnable provided to the STM compiler.
 *  \param[in] userdata Pointer to any data needed by the runnable.
 *  \return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterCpuRunnable(stmRunnable_t func, const char* const runnableId, void* userdata);

/** \brief Registers an stmCudaSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  \param[in] func STM CUDA submitter runnable function pointer.
 *  \param[in] runnableId Name of CUDA submitter runnable provided to the STM compiler.
 *  \param[in] userdata Pointer to any data needed by the runnable.
 *  \return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterCudaSubmitter(stmCudaSubmitter_t func, const char* const runnableId, void* userdata);

/** \brief Registers a CUDA stream resource.
 *
 *  \param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  \param[in] stream CUDA stream created by application.
 *  \return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if any of the following occurs:
 *      - resourceName exceeds STM_RESOURCE_NAME_MAX
 *      - the number of resources registered exceeds STM_MAX_NUM_RESOURCES
 *      - stream is the NULL stream or has not been previously created by calling cudaStreamCreate()
 *      - the same cudaStream_t has already been registered (possibly with a different resourceName)
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterCudaResource(const char* resourceName, cudaStream_t stream);

#ifdef VIBRANTE
#if VIBRANTE_PDK_DECIMAL < 6000400
/**
 * \brief Function signature for STM DLA submitter runnable.
 *
 * \remark stmDlaSumbitter_t functions should contain some CPU work, followed by some number of NvMediaDla submits. All
 * submits must be launched on the provided NvMediaDla handle. These functions should not internally launch any threads
 * or call any blocking APIs.
 */
typedef void (*stmDlaSubmitter_t)(void* userdata, NvMediaDla* dla);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000200
/**
 * \brief Function signature for STM CUDLA submitter runnable.
 *
 * \remark stmCuDlaSumbitter_t functions should contain some CPU work, followed by some number of CUDLA submits.
 * All submits must be launched on the provided CUDLA handle. These functions should not internally launch
 * any threads or call any blocking APIs. STM CUDLA Support is only enabled with the 6.0.2.0 PDK, and will fail at the link
 * stage otherwise.
 *
 * \param[out] cudla The CUDA stream created by the application used for CUDLA task submission
 */
typedef void (*stmCuDlaSubmitter_t)(void* userdata, cudaStream_t cudla);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000400
/**
 * \brief Function signature for STM VPU submitter runnable.
 *
 * \remark stmVpuSumbitter_t functions should contain some CPU work, followed by some number of VPU submits.
 * All submits must be launched on the provided CUPVA stream. These functions should not internally launch
 * any threads or call any blocking APIs. STM VPU Support is only enabled with the 6.0.4.0 PDK, and will fail at the link
 * stage otherwise.
 */
typedef void (*stmVpuSubmitter_t)(void* userdata, cupvaStream_t vpu);
#endif

#if VIBRANTE_PDK_DECIMAL < 6000400
/** \brief Registers a NvMediaDla resource.
 *
 *  \param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  \param[in] stream DLA stream created by application.
 *  \return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if any of the following occurs:
 *      - resourceName exceeds STM_RESOURCE_NAME_MAX
 *      - the number of resources registered exceeds STM_MAX_NUM_RESOURCES
 *      - dla is NULL or has not been previously created by calling NvMediaDlaCreate()
 *      - the same NvMediaDla handle has already been registered (possibly with a different resourceName)
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterDlaResource(const char* resourceName, NvMediaDla* dla);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000200
/** \brief Registers a CUDLA resource.
 *
 *  \remark STM CUDLA Support is only enabled with the 6.0.2.0 PDK, and will fail at the link stage otherwise.
 *
 *  \param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  \param[in] cudla The CUDA stream created by the application used for CUDLA task submission
 *  \return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if any of the following occurs:
 *      - resourceName exceeds STM_RESOURCE_NAME_MAX
 *      - the number of resources registered exceeds STM_MAX_NUM_RESOURCES
 *      - cudla is NULL or has not been previously created by calling cudaStreamCreate()
 *      - the same CUDA stream has already been registered (possibly with a different resourceName)
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterCuDlaResource(const char* resourceName, cudaStream_t cudla);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000400
/** \brief Registers a CUPVA resource.
 *
 *  \remark STM CUPVA Support is only enabled with the 6.0.4.0 PDK, and will fail at the link stage otherwise.
 *
 *  \param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  \param[in] vpu CUPVA stream created by application.
 *      - vpu is NULL or has not been previously created by calling cupvaStreamCreate()
 *      - the same CUPVA stream has already been registered (possibly with a different resourceName)
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterVpuResource(const char* resourceName, cupvaStream_t vpu);
#endif

#if VIBRANTE_PDK_DECIMAL < 6000400
/** \brief Registers an stmDlaSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  \param[in] func STM DLA submitter runnable function pointer.
 *  \param[in] runnableId Name of DLA submitter runnable provided to the STM compiler.
 *  \param[in] userdata Pointer to any data needed by the runnable.
 *  \return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterDlaSubmitter(stmDlaSubmitter_t func, const char* const runnableId, void* userdata);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000200
/** \brief Registers an stmCudlaSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  \remark STM CUDLA Support is only enabled with the 6.0.2.0 PDK, and will fail at the link stage otherwise.
 *
 *  \param[in] func STM CUDLA submitter runnable function pointer.
 *  \param[in] runnableId Name of CUDLA submitter runnable provided to the STM compiler.
 *  \param[in] userdata Pointer to any data needed by the runnable.
 *  \return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterCuDlaSubmitter(stmCuDlaSubmitter_t func, const char* const runnableId, void* userdata);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000400
/** \brief Registers an stmVpuSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  \remark STM CUPVA Support is only enabled with the 6.0.4.0 PDK, and will fail at the link stage otherwise.
 *
 *  \param[in] func STM CUPVA submitter runnable function pointer.
 *  \param[in] runnableId Name of CUPVA submitter runnable provided to the STM compiler.
 *  \param[in] userdata Pointer to any data needed by the runnable.
 *  \return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called.
 */
STM_API stmErrorCode_t stmRegisterVpuSubmitter(stmVpuSubmitter_t func, const char* const runnableId, void* userdata);
#endif
#endif

/** \brief Yield to STM scheduler, which will schedule all registered runnables in the STM schedule periodically until
 * completion. This function will not return until a runnable calls stmExitScheduler() or the number of epochs specified
 * in the STM master process have completed.
 *
 *  \remark All runnables and resources need to be registered prior to entering the schedule. This API will only begin
 * scheduling work after all STM clients have started. This API can only be called once per call to stmClientInit();
 * doing so multiple times will cause undefined behavior.
 *
 *  \return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_TIMEOUT if any fence timed out.
 *  - STM_ERROR_GENERIC if there was another error.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmEnterScheduler(void);

/** \brief Get runtime information about execution
 *
 *  \remark Must be called from within a CPU runnable
 *
 *  \param[out] info Pointer to stmRunnableInfo_t whose fields will be populated
 *
 *  \return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if info is NULL.
 *  - STM_ERROR_NOT_FOUND if the current STM thread could not be found.
 *  - STM_ERROR_INVALID_STATE if the requisite information could not be obtained.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmGetRuntimeInfo(stmRunnableInfo_t* info);

/** \brief Return from stmEnterScheduler().
 *
 *  \remark Called from within a runnable; causes all clients to return from their respective calls to stmEnterScheduler()
 *  at the next epoch boundary. Only needs to be called from one STM client; subsequent calls are ignored.
 *  \return stmErrorCode_t, the completion code of the operation:
 *  -STM_SUCCESS if successful.
 *  -STM_ERROR_GENERIC if any client process died or if any APIs in any STM client returned an error code.
 */
STM_API stmErrorCode_t stmExitScheduler(void);

/** \brief Cleans up STM client context. No STM APIs can be called after this.
 *
 *  \remark This API can only be called once per call to stmClientInit(); doing so multiple times will cause undefined
 *  behavior.
 */
STM_API void stmClientExit(void);

#ifdef __cplusplus
}
#endif

#endif
