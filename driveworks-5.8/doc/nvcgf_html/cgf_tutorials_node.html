<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!--
 * Copyright (c) 2022 NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA Corporation and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA Corporation is strictly prohibited.
-->
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Compute Graph Framework SDK Reference: Implement a C++ Node</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="Nvidia.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="nv.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 110px;">
  <td id="projectlogo" width="19%">
    <a id="nv-logo" href="https://www.nvidia.com/"></a>
  </td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Compute Graph Framework SDK Reference
   &#160;<span id="projectnumber">5.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('cgf_tutorials_node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Implement a C++ Node </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md136">Node Header</a><ul><li class="level2"><a href="#autotoc_md137">Base Class</a></li>
<li class="level2"><a href="#autotoc_md138">Instantiation (Declaration)</a></li>
<li class="level2"><a href="#autotoc_md139">Introspection</a><ul><li class="level3"><a href="#autotoc_md140">Ports</a></li>
<li class="level3"><a href="#autotoc_md141">Passes</a></li>
<li class="level3"><a href="#autotoc_md142">Parameters</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md143">Node Source</a><ul><li class="level2"><a href="#autotoc_md144">Enum Description</a></li>
<li class="level2"><a href="#autotoc_md145">Instantiation (Definition)</a></li>
<li class="level2"><a href="#autotoc_md146">Discovery</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md147">Impl Header</a><ul><li class="level2"><a href="#autotoc_md148">Impl Base Class</a></li>
<li class="level2"><a href="#autotoc_md149">Constructor and Initialization (Declaration)</a></li>
<li class="level2"><a href="#autotoc_md150">Pass Methods</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md151">Impl Source</a><ul><li class="level2"><a href="#autotoc_md152">Constructor and Initialization (Definition)</a></li>
<li class="level2"><a href="#autotoc_md153">Pass Implementation</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md154">Generating Node Descriptor</a></li>
</ul>
</div>
<div class="textblock"><p >The <a class="el" href="classdw_1_1framework_1_1Node.html">dw::framework::Node</a> interface prescribes a set of virtual functions which each node must implement. While not a requirement, the instructions apply the <em>pointer to implementation</em> (PIMPL) idiom to hide implementation details and reduce compilation dependencies.</p>
<p >The following subsections show how to implement a node named <code>my_ns::MyNode</code>.</p>
<h1><a class="anchor" id="autotoc_md136"></a>
Node Header</h1>
<h2><a class="anchor" id="autotoc_md137"></a>
Base Class</h2>
<p >The <code>MyNode</code> class needs to implement the <a class="el" href="classdw_1_1framework_1_1Node.html">dw::framework::Node</a> interface. With the implementation being hidden in another class (called <b>Impl</b>) which is only known to the source file, all functions of the interface must be relayed to an <b>Impl</b> instance. During that relaying an additional functionality can be easily integrated: catching potential exceptions thrown in the <b>Impl</b> class and return <b>dwStatus</b> instead. </p><pre class="fragment">namespace my_ns
{
class MyNode : public dw::framework::ExceptionSafeProcessNode
{
    ...
}
} // namespace my_ns
</pre><p> Every node must define a set of static functions used to introspect the interface of the node as well as to instantiate a node. These static functions are documented in <a class="el" href="classdw_1_1framework_1_1NodeConcept.html" title="The class only exists for documentation.">dw::framework::NodeConcept</a>.</p>
<h2><a class="anchor" id="autotoc_md138"></a>
Instantiation (Declaration)</h2>
<p >The node constructor can have arbitrary arguments. Commonly they are structured in the following way:</p>
<ul>
<li>A struct containing the parameters which can't be changed after construction, e.g. <code>struct MyNodeParams</code>.</li>
<li>Other handles needed by the node, e.g. <code>dwContextHandle_t</code>.</li>
</ul>
<pre class="fragment">    MyNode(const MyNodeParams&amp; params, const MyNodeRuntimeParams&amp; runtimeParams, dwContextHandle_t ctx);
</pre><p> A factory function enables the instantiation of any node in a uniform way. The parameter provider can retrieve the parameter value for all parameters declared in the <a class="el" href="namespacedw_1_1framework.html#aa84c8201885f22decb53bac385240054" title="Get described parameters for the passed node.">describeParameters()</a> function. The information from the <a class="el" href="namespacedw_1_1framework.html#aa84c8201885f22decb53bac385240054" title="Get described parameters for the passed node.">describeParameters()</a> function also allows to map these parameter values to the necessary constructor arguments and members within a constructor argument. </p><pre class="fragment">    static std::unique_ptr&lt;MyNode&gt; create(dw::framework::ParameterProvider&amp;);
</pre> <h2><a class="anchor" id="autotoc_md139"></a>
Introspection</h2>
<h3><a class="anchor" id="autotoc_md140"></a>
Ports</h3>
<p >All input/output ports are enumerated in a user defined order. For each port the unique name and C++ data type must be declared. Additionally, optional flags can be specified, e.g. if a port must be bound to a channel in order for the node to be consider to be in a valid state. </p><pre class="fragment">    static constexpr auto describeInputPorts()
    {
        return dw::framework::describePortCollection(
            DW_DESCRIBE_PORT(TypeFoo, "FOO"),
            DW_DESCRIBE_PORT(TypeBar, "BAR", dw::framework::PortBinding::REQUIRED),
            DW_DESCRIBE_PORT_ARRAY(TypeBaz, 3, "BAZ")
        );
    }

    static constexpr auto describeOutputPorts() {
        return dw::framework::describePortCollection(
            DW_DESCRIBE_PORT(TypeOut, "OUT"),
        );
    }
</pre> <h3><a class="anchor" id="autotoc_md141"></a>
Passes</h3>
<p >All passes are enumerated in their execution order. By convention the first pass is named <b>SETUP</b> and the last pass is named <b>TEARDOWN</b>. Beside the unique name the processor type where the computation is happening must be declared. </p><pre class="fragment">    static constexpr auto describePasses()
    {
        return dw::framework::describePassCollection(
            dw::framework::describePass("SETUP", DW_PROCESSOR_TYPE_CPU),
            dw::framework::describePass("PROCESS", DW_PROCESSOR_TYPE_GPU),
            dw::framework::describePass("AGGREGATE", DW_PROCESSOR_TYPE_CPU),
            dw::framework::describePass("TEARDOWN", DW_PROCESSOR_TYPE_CPU),
        );
    }
</pre> <h3><a class="anchor" id="autotoc_md142"></a>
Parameters</h3>
<p >All parameters declare a mapping to constructor arguments or members within a constructor argument. While the constructor arguments must be declared in the same order as they appear in the constructor signature, the parameters within each are enumerated in a user defined order. </p><pre class="fragment">    static constexpr auto describeParameters()
    {
        return dw::framework::describeConstructorArguments&lt;
            MyNodeParams,
            MyNodeRuntimeParams,
            dwContextHandle_t,
        &gt;(
            dw::framework::describeConstructorArgument(
                DW_DESCRIBE_..._PARAMETER(...),
                DW_DESCRIBE_..._PARAMETER(...),
                ...
                DW_DESCRIBE_..._PARAMETER(...)
            ),
            dw::framework::describeConstructorArgument(
                ...
            ),
            dw::framework::describeConstructorArgument(
                ...
            )
        );
    }
</pre><p> There are various kinds of parameters and for each there is a corresponding macro. All of these macros start with <code>DW_DESCRIBE_</code> and end with <code>PARAMETER</code>.</p>
<p >For all parameters the C++ type needs to be specified as the first argument which must match the variable type the value will be stored in. Optionally a semantic type can be provided (see "Parameter Details" under <a class="el" href="cgf_details_node.html">Details/Node</a>).</p>
<p >The destination where the parameter value should be stored is specified at the end of the argument list.</p>
<ul>
<li>Commonly a single destination argument is used to provide the member pointer within the struct (see <code>describeConstructorArgument(DW_DESCRIBE_PARAMETER(..., &amp;HelloWorldNodeParams::name))</code> in HelloWorldNode.hpp).</li>
<li>Multiple destination arguments can be used to identify a nested member, each argument being a member point of the struct in each level. E.g. for two destination arguments like <code><a class="el" href="ParameterDescriptor_8hpp.html#afc34a6220c8f153cea3038d92590df87">DW_DESCRIBE_PARAMETER(..., &amp;MyNodeParams::memberWhichIsAStruct, &amp;MyNodeParamsSubStruct::nestedMember)</a></code> the value is stored in the nested member <code>constructorArgument.memberWhichIsAStruct.nestedMember</code>.</li>
<li>No destination arguments are specified when: either the parameter is the only parameter representing a constructor argument and the constructor argument itself should be the parameter value (see <code>describeConstructorArgument(DW_DESCRIBE_UNNAMED_PARAMETER(dwContextHandle_t))</code> in HelloWorldNode.hpp) or for <code>ABSTRACT</code> parameters where the destination is determined by custom logic.</li>
</ul>
<p >The signature of each of the following macros can be discovered by following the documentation of the macro to the function which is invoked by the macro.</p>
<ul>
<li><p class="startli"><a class="el" href="ParameterDescriptor_8hpp.html#afc34a6220c8f153cea3038d92590df87">DW_DESCRIBE_PARAMETER()</a> / <a class="el" href="ParameterDescriptor_8hpp.html#a00a4adeee59e7b24525a2d8350771a11">DW_DESCRIBE_PARAMETER_WITH_SEMANTIC()</a></p>
<p class="startli">The parameter value is read from JSON.</p><ul>
<li><p class="startli"><a class="el" href="ParameterDescriptor_8hpp.html#af84238622bb641cae05d10456936a161">DW_DESCRIBE_ARRAY_PARAMETER()</a> / <a class="el" href="ParameterDescriptor_8hpp.html#ade638324caa904877a9762015a2b0229">DW_DESCRIBE_ARRAY_PARAMETER_WITH_SEMANTIC()</a></p>
<p class="startli">An array of such parameters.</p>
</li>
</ul>
</li>
<li><p class="startli"><a class="el" href="ParameterDescriptor_8hpp.html#a24a34023a3c6ef4869c47abb66b3b193">DW_DESCRIBE_INDEX_PARAMETER()</a> / <a class="el" href="ParameterDescriptor_8hpp.html#a1b9290839c76307110502bd885d86569">DW_DESCRIBE_INDEX_PARAMETER_WITH_SEMANTIC()</a></p>
<p class="startli">The parameter value is read from JSON but since the JSON key contains an array an additional index is required to retrieve a specific item from that array.</p>
</li>
<li><p class="startli"><a class="el" href="ParameterDescriptor_8hpp.html#a72f2a437a373cac3f5622fd88c60eea8">DW_DESCRIBE_UNNAMED_PARAMETER()</a> / <a class="el" href="ParameterDescriptor_8hpp.html#a5280cfa44169a756ff66e27dcd5bc919">DW_DESCRIBE_UNNAMED_PARAMETER_WITH_SEMANTIC()</a></p>
<p class="startli">Parameter value isn't coming from JSON but from a global singleton or some other context.</p><ul>
<li><p class="startli"><a class="el" href="ParameterDescriptor_8hpp.html#aec267144fbf2c1e07ff422ef1535b977">DW_DESCRIBE_UNNAMED_ARRAY_PARAMETER()</a> / <a class="el" href="ParameterDescriptor_8hpp.html#a4e272fde520c36594aa94265cc38effc">DW_DESCRIBE_UNNAMED_ARRAY_PARAMETER_WITH_SEMANTIC()</a></p>
<p class="startli">An array of such parameters.</p>
</li>
</ul>
</li>
<li><p class="startli"><a class="el" href="ParameterDescriptor_8hpp.html#aaafeee9b3f75a1dd29e14ca1208eea5c">DW_DESCRIBE_ABSTRACT_PARAMETER()</a> / <a class="el" href="ParameterDescriptor_8hpp.html#a3852f291017d9969bdd463a63b233960">DW_DESCRIBE_ABSTRACT_ARRAY_PARAMETER()</a></p>
<p class="startli">The parameter value is read from JSON but <b>not</b> automatically stored in a constructor arguments or member within a constructor argument. Instead the node can use custom logic in the <code><a class="el" href="namespacedw_1_1framework.html#acf4210bb80092ef24ce74a7cc90e3494">create()</a></code> function to utilize the parameter in a non-standard way (see below).</p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md143"></a>
Node Source</h1>
<h2><a class="anchor" id="autotoc_md144"></a>
Enum Description</h2>
<p >Beside primitive types or arrays thereof, a parameter can also be of enum type. For such an enum type a mapping must exist which correlates the integer value with a string representation. Commonly the identifier of each enumerator is being used. To define the mapping mentioned in the previous section, a specialization of the templated struct <a class="el" href="structdw_1_1framework_1_1EnumDescription.html">dw::framework::EnumDescription()</a> needs to be defined.</p>
<p >For C enums this specialization can be places in the <code>.cpp</code> of the concrete node using a parameter with that enum type. </p><pre class="fragment">template &lt;&gt;
struct EnumDescription&lt;MyEnum&gt;
{
    static constexpr auto get()
    {
        return describeEnumeratorCollection&lt;MyEnum&gt;(
            DW_DESCRIBE_C_ENUMERATOR(NAME_OF_ENUMERATOR_1),
            DW_DESCRIBE_C_ENUMERATOR(NAME_OF_ENUMERATOR_2),
            ...
            DW_DESCRIBE_C_ENUMERATOR(NAME_OF_ENUMERATOR_N)
        );
    }
};
</pre><p> For C++ enum classes this specialization should <b>not</b> be placed in the nodes sources but wherever the enum class definition is located. </p><pre class="fragment">template &lt;&gt;
struct EnumDescription&lt;MyEnum&gt;
{
    static constexpr auto get()
    {
        using EnumT = MyEnum;
        return describeEnumeratorCollection&lt;EnumT&gt;(
            DW_DESCRIBE_ENUMERATOR(NAME_OF_ENUMERATOR_1),
            DW_DESCRIBE_ENUMERATOR(NAME_OF_ENUMERATOR_2),
            ...
            DW_DESCRIBE_ENUMERATOR(NAME_OF_ENUMERATOR_N)
        );
    }
};
</pre> <h2><a class="anchor" id="autotoc_md145"></a>
Instantiation (Definition)</h2>
<p >The base class constructor expects a unique_ptr to a node. As such an instance of the <b>Impl</b> class is passed which commonly has the same constructor signature as the concrete node. </p><pre class="fragment">MyNode::MyNode(const MyNodeParams&amp; params, const MyNodeRuntimeParams&amp; runtimeParams, dwContextHandle_t ctx)
    : dw::framework::ExceptionSafeNode(std::make_unique&lt;MyNodeImpl&gt;(params, runtimeParams, ctx))
{}
</pre><p> For the factory functions there are two implementation options:</p>
<ol type="1">
<li>If the mapping of declared parameters to constructor arguments (members) is 1-to-1 without the need for custom logic, it just relays the call to the function <a class="el" href="namespacedw_1_1framework.html#acf4210bb80092ef24ce74a7cc90e3494">dw::framework::create()</a> which implements the mapping generically. <pre class="fragment">std::unique_ptr&lt;MyNode&gt; MyNode::create(dw::framework::ParameterProvider&amp; provider)
{
    return dw::framework::create&lt;MyNode&gt;(provider);
}
</pre></li>
<li>If custom logic is needed it can be implemented between the calls <a class="el" href="namespacedw_1_1framework.html#a73f86ed3548181cdecdb500b415cc0ff" title="Create a tuple of constructor argument needed by the constructor of the passed node.">dw::framework::createConstructorArguments()</a> and <a class="el" href="namespacedw_1_1framework.html#a32312d4140dae322fb580cca74246e58" title="Instantiate a node using the passed constructor arguments.">dw::framework::makeUniqueFromTuple()</a>: <pre class="fragment">std::unique_ptr&lt;MyNode&gt; MyNode::create(dw::framework::ParameterProvider&amp; provider)
{
    auto constructorArguments = dw::framework::createConstructorArguments&lt;MyNode&gt;();

    // to access individual constructor arguments by index:
    MyNodeParams&amp; params = std::get&lt;0&gt;(constructorArguments);
    MyNodeRuntimeParams&amp; runtimeParams = std::get&lt;1&gt;(constructorArguments);
    // arbitrary logic
    // e.g. reading two abstract parameters and using them together to populate the constructor argument
    size_t index;
    provider.getRequired("index", &amp;index);  // get an index from the JSON config file
    provider.getRequired("enabled", index, &amp;(params.enable));  // extract a single flag from an array of flag using the index

    dw::framework::populateParameters&lt;MyNode&gt;(constructorArguments, provider);

    return dw::framework::makeUniqueFromTuple&lt;MyNode&gt;(std::move(constructorArguments));
}
</pre> </li>
</ol>
<h2><a class="anchor" id="autotoc_md146"></a>
Discovery</h2>
<p >Registering the node type allows it to be discovered and instantiated by its string name.</p>
<p >The registration with <a class="el" href="NodeFactory_8hpp.html#ac24266d389f77349b988f8d901d1d15e">DW_REGISTER_NODE()</a> should happen outside of the namespace and must use the fully qualified typename. </p><pre class="fragment">namespace my_ns
{
    ...
}

DW_REGISTER_NODE(my_ns::MyNode)
</pre> <h1><a class="anchor" id="autotoc_md147"></a>
Impl Header</h1>
<h2><a class="anchor" id="autotoc_md148"></a>
Impl Base Class</h2>
<p >The implementation class should inherit from a base class which not only implements the node interface but provides a default implementation for various functions. While the base class <a class="el" href="classdw_1_1framework_1_1SimpleNode.html">dw::framework::SimpleNode()</a> provides all the necessary functionality, subclassing from <a class="el" href="classdw_1_1framework_1_1SimpleNodeT.html">dw::framework::SimpleNodeT()</a> enables the usage of various macros later which can utilize the type of the node class. </p><pre class="fragment">class MyNodeImpl : public dw::framework::SimpleNodeT&lt;MyNode&gt;
{
    ...
}
</pre> <h2><a class="anchor" id="autotoc_md149"></a>
Constructor and Initialization (Declaration)</h2>
<p >The class should have a constructor with the same signature as the non-impl class. </p><pre class="fragment">    MyNodeImpl(const MyNodeParams&amp; params, const MyNodeRuntimeParams&amp; runtimeParams, dwContextHandle_t ctx);
</pre><p> In order to provide default implementations with rich functionality for various functions, the <a class="el" href="classdw_1_1framework_1_1SimpleNode.html">dw::framework::SimpleNode()</a> class needs to know about the ports and passes of the node. Those need to be initialize / registered and by convention that happens in a function init() which will be called in the constructor. </p><pre class="fragment">    void init();
</pre> <h2><a class="anchor" id="autotoc_md150"></a>
Pass Methods</h2>
<p >Additionally, for each pass (except the conventional ones <b>SETUP</b> and <b>TEARDOWN</b>) a method is declared to implement the logic of that pass. The methods can't take any argument, instead information can be passed between passes using member variables of the class. </p><pre class="fragment">    dwStatus processPass();
    dwStatus aggregatePass();
</pre> <h1><a class="anchor" id="autotoc_md151"></a>
Impl Source</h1>
<h2><a class="anchor" id="autotoc_md152"></a>
Constructor and Initialization (Definition)</h2>
<p >The constructor of the Impl class commonly stores the constructor arguments in member variables for later usage. </p><pre class="fragment">MyNodeImpl::MyNodeImpl(const MyNodeParams&amp; params, const MyNodeRuntimeParams&amp; runtimeParams, dwContextHandle_t ctx)
    : m_params(params), m_runtimeParams(runtimeParams), m_ctx(ctx)
{
    init();
}
</pre><p> For the <a class="el" href="classdw_1_1framework_1_1SimpleNode.html">dw::framework::SimpleNode()</a> base class to function properly, in the <code>init()</code> function:</p>
<ul>
<li>All input ports must be initialized by calling the appropriate macro with the name of the port:<ul>
<li><a class="el" href="SimpleNodeT_8hpp.html#a74f76320e8780e083d8605a80581c15a" title="Initialize a non-array input port with the node base class.">NODE_INIT_INPUT_PORT()</a></li>
<li><a class="el" href="SimpleNodeT_8hpp.html#af1de63ffbbba2c48f81e04df4b3ea3f5" title="Initialize an array input port with the node base class.">NODE_INIT_INPUT_ARRAY_PORT()</a></li>
</ul>
</li>
<li>All output ports must be initialized by calling the appropriate macro with the name of the port as well as a reference data to initialize the internal data storage with:<ul>
<li><a class="el" href="SimpleNodeT_8hpp.html#a4c1e79258c354dee498d1086f3547849" title="Initialize a non-array output port with the node base class.">NODE_INIT_OUTPUT_PORT()</a></li>
<li><a class="el" href="SimpleNodeT_8hpp.html#ab5ecd956bfc3a49e57a8061b9cd62829" title="Initialize an array output port with the node base class.">NODE_INIT_OUTPUT_ARRAY_PORT()</a></li>
</ul>
</li>
<li>All passes except <b>SETUP</b> and <b>TEARDOWN</b> must be registered with the name of the pass as well as a lambda function for the pass logic.</li>
</ul>
<pre class="fragment">void MyNodeImpl::init()
{
    NODE_INIT_INPUT_PORT("FOO"_sv);
    NODE_INIT_INPUT_PORT("BAR"_sv);
    NODE_INIT_INPUT_ARRAY_PORT("BAZ"_sv);

    TypeOut ref{};
    NODE_INIT_OUTPUT_PORT("OUT"_sv, ref);

    NODE_REGISTER_PASS("PROCESS"_sv, [this]() {
        return processPass();
    });
    NODE_REGISTER_PASS("AGGREGATE"_sv, [this]() {
        return aggregatePass();
    });
}
</pre><p> There is no need for the concrete impl class to contain any member variables for <a class="el" href="classdw_1_1framework_1_1Port.html">dw::framework::Port</a> instance. Instead, these can be retrieved from the base class using one of the following macros by passing the port name and for array port additionally the index:</p>
<ul>
<li><a class="el" href="SimpleNodeT_8hpp.html#a0920ed8cf966bfcbc1d91b0f3499129a" title="Get a previously initialized non-array input port.">NODE_GET_INPUT_PORT()</a></li>
<li><a class="el" href="SimpleNodeT_8hpp.html#ae1972d2aad340d520a8dafc6fcad00a6" title="Get one specific input port of a previously initialized array input port.">NODE_GET_INPUT_ARRAY_PORT()</a></li>
<li><a class="el" href="SimpleNodeT_8hpp.html#ac0c7d73eae64a3056834407a6b92a3df" title="Get a previously initialized non-array output port.">NODE_GET_OUTPUT_PORT()</a></li>
<li><a class="el" href="SimpleNodeT_8hpp.html#ad877aaca6360845fdd699e358a97956b" title="Get one specific output port of a previously initialized array output port.">NODE_GET_OUTPUT_ARRAY_PORT()</a></li>
</ul>
<p >Similarly, there is no need to store <a class="el" href="classdw_1_1framework_1_1Pass.html" title="Pass is a runnable describes the metadata of a pass.">dw::framework::Pass</a> instances in member variables in the concrete node.</p>
<h2><a class="anchor" id="autotoc_md153"></a>
Pass Implementation</h2>
<p >Implementation of the pass methods declared in the header with the desired logic.</p>
<h1><a class="anchor" id="autotoc_md154"></a>
Generating Node Descriptor</h1>
<p >The <a class="el" href="cgf_tools_nodedescriptor.html">nodedescriptor</a> tool can be used to generate the <code>MyNode.node.json</code> file based on the information provided by the introspection API.</p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
