/////////////////////////////////////////////////////////////////////////////////////////
//
// Notice
// ALL NVIDIA DESIGN SPECIFICATIONS AND CODE ("MATERIALS") ARE PROVIDED "AS IS" NVIDIA MAKES
// NO REPRESENTATIONS, WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
//
// NVIDIA CORPORATION & AFFILIATES assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA CORPORATION & AFFILIATES. No third party distribution is allowed unless
// expressly authorized by NVIDIA. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA CORPORATION & AFFILIATES products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA CORPORATION & AFFILIATES.
//
// SPDX-FileCopyrightText: Copyright (c) 2018-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: LicenseRef-NvidiaProprietary
//
// NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
// property and proprietary rights in and to this material, related
// documentation and any modifications thereto. Any use, reproduction,
// disclosure or distribution of this material and related documentation
// without an express license agreement from NVIDIA CORPORATION or
// its affiliates is strictly prohibited.
//
/////////////////////////////////////////////////////////////////////////////////////////

/**
 * @file stm.h
 *
 * @brief STM Runtime
 *
 * Overview:
 * STM is a co-operative, non-preemptive, static scheduling framework for real-time systems.
 * The STM runtime is a library that executes a schedule produced offline by the STM compiler, enforcing
 * data dependency ordering and control flow ordering across engines on a Tegra SoC.
 *
 * STM Clients:
 * Every STM client corresponds to an OS process. All STM clients mentioned to the STM compiler must be launched before
 * any STM client will begin scheduling runnables.
 *
 * STM Master:
 * Alongside STM clients, the STM master executable needs to be launched and passed a .stm file generated by the
 * STM compiler. STM clients will block at the call to stmClientInit() until the STM master process has been launched.
 **/

#ifndef STM_H_
#define STM_H_

#if __GNUC__ >= 4
#define STM_API __attribute__((visibility("default")))
#endif

#include <stdint.h>
#include "stm_error.h"
#include <cuda_runtime.h>
#include <stdbool.h>
#include <nvscisync.h>

#ifdef VIBRANTE
#if VIBRANTE_PDK_DECIMAL < 6000400
#include <nvmedia_dla.h>
#endif
#if VIBRANTE_PDK_DECIMAL >= 6000000
#include <cupva_host_wrapper.h>
#if VIBRANTE_PDK_DECIMAL >= 6000400
#include <cudla.h>
#if VIBRANTE_PDK_DECIMAL >= 6000500
#include <VulkanSC/vulkan/vulkan_sc.h>
#if VIBRANTE_PDK_DECIMAL >= 6000600
#include <nvmedia_6x/nvmedia_ldc.h>
#include <nvmedia_6x/nvmedia_2d.h>
#endif
#endif
#endif
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Information which can be queried by CPU runnables using stmGetRuntimeInfo()
 */
typedef struct
{
    uint32_t epochIterations;
    uint16_t scheduleId;
} stmRunnableInfo_t;

/**
 * @brief Function signature for STM CPU runnable.
 *
 * @remark stmRunnable_t functions should only contain CPU work. They should not call any blocking APIs or internally
 * launch any threads.
 */
typedef void (*stmRunnable_t)(void* userdata);

/**
 * @brief Function signature for STM CUDA submitter runnable.
 *
 * @remark stmCudaSubmitter_t functions should contain some CPU work, followed by some number of asynchronous
 * CUDA kernel launches. All kernels launched in submitter must be launched onto cudaStream_t stream. The use of stream 0
 * (the null stream) is prohibited due to CUDA's implicit synchronization semantics. This function should not internally
 * launch any threads or call any blocking APIs, including cudaMemcpy(), cudaMemset(), cudaFree(), etc..
 *
 * @param[in] userdata Pointer to any data needed by the runnable
 * @param[in] stream CUDA stream created by application for the kernels
 */
typedef void (*stmCudaSubmitter_t)(void* userdata, cudaStream_t stream);

/** @brief Initialize STM client context.
 *
 *  @remark This API will block until the STM master process is started.
 *  Client contexts should be cleaned up with stmClientExit() after STM has completed its execution.
 *  Same as calling stmClientInitWithDiscriminator() with \p discriminator = -1.
 *  Calling this after registering resources and runnables will allow the client to also receive schedule
 *  information here instead of in stmEnterScheduler.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_GENERIC if some error occured.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmClientInit(const char* clientName);

/** @brief Initialize STM client context with a discriminator.
 *
 *  @remark This API will block until the STM master process with this \p discriminator is started.
 *  Client contexts should be cleaned up with stmClientExit() after STM has completed its execution.
 *  Client must call at most one of the two: stmClientInit() or stmClientInitWithDiscriminator()
 *  All negative values of \p discriminator are equivalent and the same as calling stmClientInit()
 *  Calling this after registering resources and runnables will allow the client to also receive schedule
 *  information here instead of in stmEnterScheduler.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_GENERIC if some error occured.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmClientInitWithDiscriminator(const char* clientName, int32_t discriminator);

/** @brief Registers an stmRunnable_t function with the name provided by the user to the STM compiler.
 *
 *  @param[in] func STM CPU runnable function pointer.
 *  @param[in] runnableId Name of CPU runnable provided to the STM compiler.
 *  @param[in] userdata Pointer to any data needed by the runnable.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_GENERIC if some other error occured.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterCpuRunnable(stmRunnable_t func, const char* const runnableId, void* userdata);

/** @brief Registers an stmCudaSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  @param[in] func STM CUDA submitter runnable function pointer.
 *  @param[in] runnableId Name of CUDA submitter runnable provided to the STM compiler.
 *  @param[in] userdata Pointer to any data needed by the runnable.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_GENERIC if some other error occured.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterCudaSubmitter(stmCudaSubmitter_t func, const char* const runnableId, void* userdata);

/** @brief Registers a CUDA stream resource.
 *
 *  @param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  @param[in] stream CUDA stream created by application.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if any of the following occurs:
 *      - resourceName exceeds STM_RESOURCE_NAME_MAX
 *      - the number of resources registered exceeds STM_MAX_NUM_RESOURCES
 *      - stream is the NULL stream or has not been previously created by calling cudaStreamCreate()
 *      - the same cudaStream_t has already been registered (possibly with a different resourceName)
 * - STM_ERROR_GENERIC if some other error occured.
 * - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterCudaResource(const char* resourceName, cudaStream_t stream);

#ifdef VIBRANTE

#if VIBRANTE_PDK_DECIMAL >= 6000500
STM_API stmErrorCode_t stmRegisterVulkanResource(const char* resourceName, VkQueue queue, VkDevice device, VkPhysicalDevice physicalDevice, VkInstance instance);

typedef void (*stmVulkanSubmitter_t)(void* userdata, VkQueue queue);

STM_API stmErrorCode_t stmRegisterVulkanSubmitter(stmVulkanSubmitter_t func, const char* const runnableId, void* userdata);
#endif

#if VIBRANTE_PDK_DECIMAL < 6000400
/**
 * @brief Function signature for STM DLA submitter runnable.
 *
 * @remark stmDlaSubmitter_t functions should contain some CPU work, followed by some number of NvMediaDla submits. All
 * submits must be launched on the provided NvMediaDla handle. These functions should not internally launch any threads
 * or call any blocking APIs.
 *
 * @param[in] userdata Pointer to any data needed by the runnable
 * @param[in] dla DLA handle created by application
 */
typedef void (*stmDlaSubmitter_t)(void* userdata, NvMediaDla* dla);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000200
/**
 * @brief Function signature for STM cuDLA hybrid submitter runnable.
 *
 * @remark stmCuDlaSubmitter_t functions should contain some CPU work, followed by some number of cuDLA hybrid submits.
 * All submits must be launched on the provided CUDA stream. These functions should not internally launch
 * any threads or call any blocking APIs. STM cuDLA hybrid Support is only enabled with the 6.0.2.0 PDK, and will fail at the link
 * stage otherwise.
 *
 * @param[in] userdata Pointer to any data needed by the runnable
 * @param[in] cudla CUDA stream created by application
 */
typedef void (*stmCuDlaSubmitter_t)(void* userdata, cudaStream_t cudla);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000600
/**
 * @brief Function signature for STM LDC submitter runnable.
 *
 * @remark stmLdcSubmitter_t functions should contain some CPU work, followed by some number of NvMediaLdc process calls. All
 * process calls must be launched on the provided NvMediaLdc handle. These functions should not internally launch any threads
 * or call any blocking APIs.
 *
 * @param[in] userdata Pointer to any data needed by the runnable
 * @param[in] ldc LDC handle created by application
 * @param[in] ldcPrefenceList List of prefences the application needs to insert
 * @param[in] ldcPrefenceCount Count of prefences that need to be inserted
 * @param[in] ldcPostfencesyncObj Sync obj on which NvMediaLdcSetNvSciSyncObjforEOF needs to be called
 * @param[out] ldcPostfence Pointer to post fence which the application needs to provide stm with
 */
typedef void (*stmLdcSubmitter_t)(void* userdata, NvMediaLdc* ldc, NvSciSyncFence const ldcPrefenceList[], size_t ldcPrefenceCount, NvSciSyncObj ldcPostfencesyncObj, NvSciSyncFence* ldcPostfence);

/**
 * @brief Function signature for STM nv2D submitter runnable.
 *
 * @remark stmNv2DSubmitter_t functions should contain some CPU work, followed by some number of NvMedia2D process calls. All
 * process calls must be launched on the provided NvMedia2D handle. These functions should not internally launch any threads
 * or call any blocking APIs.
 *
 * @param[in] userdata Pointer to any data needed by the runnable
 * @param[in] nv2D NVMEDIA_2D handle created by application
 * @param[in] nv2DPrefenceList List of prefences the application needs to insert
 * @param[in] nv2DPrefenceCount Count of prefences that need to be inserted
 * @param[in] nv2DPostfencesyncObj Sync obj on which NvMedia2DSetNvSciSyncObjforEOF needs to be called
 * @param[out] nv2DPostfence Pointer to post fence which the application needs to provide stm with
 */
typedef void (*stmNv2DSubmitter_t)(void* userdata, NvMedia2D* nv2D, NvSciSyncFence const nv2DPrefenceList[], size_t nv2DPrefenceCount, NvSciSyncObj nv2DPostfencesyncObj, NvSciSyncFence* nv2DPostfence);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000400
/**
 * @brief Function signature for STM cuDLA standalone submitter runnable.
 *
 * @remark stmCuDlaStandaloneSubmitter_t functions should contain some CPU work, followed by some number of cuDLA standalone submits.
 * All submits must be launched on the provided cuDLA handle. These functions should not internally launch
 * any threads or call any blocking APIs. STM cuDLA standalone Support is only enabled with the 6.0.4.0 PDK, and will fail at the link
 * stage otherwise.
 *
 * @param[in] userdata Pointer to any data needed by the runnable
 * @param[in] cudla cuDLA device handle created by application
 */
typedef void (*stmCuDlaStandaloneSubmitter_t)(void* userdata, cudlaDevHandle cudla);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000000
/**
 * @brief Function signature for STM VPU submitter runnable.
 *
 * @remark stmVpuSubmitter_t functions should contain some CPU work, followed by some number of VPU submits.
 * All submits must be launched on the provided cuPVA stream. These functions should not internally launch
 * any threads or call any blocking APIs. STM VPU Support is only enabled with the 6.0.0.0 PDK, and will fail at the link
 * stage otherwise.
 *
 * @param[in] userdata Pointer to any data needed by the runnable
 * @param[in] vpu cuPVA stream created by application
 */
typedef void (*stmVpuSubmitter_t)(void* userdata, cupvaStream_t vpu);
#endif

#if VIBRANTE_PDK_DECIMAL < 6000400
/**
 * @brief Registers a NvMediaDla resource.
 *
 *  @param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  @param[in] dla DLA stream created by application.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if any of the following occurs:
 *      - resourceName exceeds STM_RESOURCE_NAME_MAX
 *      - the number of resources registered exceeds STM_MAX_NUM_RESOURCES
 *      - dla is NULL or has not been previously created by calling NvMediaDlaCreate()
 *      - the same NvMediaDla handle has already been registered (possibly with a different resourceName)
 * - STM_ERROR_GENERIC if some other error occured.
 * - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterDlaResource(const char* resourceName, NvMediaDla* dla);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000200
/**
 * @brief Registers a cuDLA hybrid resource.
 *
 *  @remark STM cuDLA hybrid Support is only enabled with the 6.0.2.0 PDK, and will fail at the link stage otherwise.
 *
 *  @param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  @param[in] cudla The CUDA stream created by the application used for cuDLA task submission
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if any of the following occurs:
 *      - resourceName exceeds STM_RESOURCE_NAME_MAX
 *      - the number of resources registered exceeds STM_MAX_NUM_RESOURCES
 *      - cudla is NULL or has not been previously created by calling cudaStreamCreate()
 *      - the same CUDA stream has already been registered (possibly with a different resourceName)
 * - STM_ERROR_GENERIC if some other error occured.
 * - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterCuDlaResource(const char* resourceName, cudaStream_t cudla);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000600
/**
 * @brief Registers a NvMediaLdc resource.
 *
 *  @param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  @param[in] ldc LDC handle created by application.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if any of the following occurs:
 *      - resourceName exceeds STM_RESOURCE_NAME_MAX
 *      - the number of resources registered exceeds STM_MAX_NUM_RESOURCES
 *      - ldc is NULL or has not been previously created by calling NvMediaLdcCreate()
 *      - the same NvMediaLdc handle has already been registered (possibly with a different resourceName)
 * - STM_ERROR_GENERIC if some other error occured.
 * - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterLdcResource(const char* resourceName, NvMediaLdc* ldc);

/**
 * @brief Registers a NvMedia2D resource.
 *
 *  @param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  @param[in] nv2D 2D handle created by application.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if any of the following occurs:
 *      - resourceName exceeds STM_RESOURCE_NAME_MAX
 *      - the number of resources registered exceeds STM_MAX_NUM_RESOURCES
 *      - nv2D is NULL or has not been previously created by calling NvMedia2DCreate()
 *      - the same NvMedia2D handle has already been registered (possibly with a different resourceName)
 * - STM_ERROR_GENERIC if some other error occured.
 * - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterNv2DResource(const char* resourceName, NvMedia2D* nv2D);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000400
/**
 * @brief Registers a cuDLA standalone resource.
 *
 *  @remark STM cuDLA standalone Support is only enabled with the 6.0.4.0 PDK, and will fail at the link stage otherwise.
 *
 *  @param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  @param[in] cudla The cuDLA device handle created by the application used for cuDLA task submission
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if any of the following occurs:
 *      - resourceName exceeds STM_RESOURCE_NAME_MAX
 *      - the number of resources registered exceeds STM_MAX_NUM_RESOURCES
 *      - cudla is NULL or has not been previously created by calling cudlaCreateDevice()
 *      - the same cuDLA device handle has already been registered (possibly with a different resourceName)
 * - STM_ERROR_GENERIC if some other error occured.
 * - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterCuDlaStandaloneResource(const char* resourceName, cudlaDevHandle cudla);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000000
/**
 * @brief Registers a cuPVA resource.
 *
 *  @remark STM cuPVA Support is only enabled with the 6.0.0.0 PDK, and will fail at the link stage otherwise.
 *
 *  @param[in] resourceName Name of resource. Needs to match resource name passed to STM compiler.
 *  @param[in] vpu cuPVA stream created by application.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if any of the following occurs:
 *      - resourceName exceeds STM_RESOURCE_NAME_MAX
 *      - the number of resources registered exceeds STM_MAX_NUM_RESOURCES
 *      - vpu is NULL or has not been previously created by calling cupvaStreamCreate()
 *      - the same cuPVA stream has already been registered (possibly with a different resourceName)
 * - STM_ERROR_GENERIC if some other error occured.
 * - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterVpuResource(const char* resourceName, cupvaStream_t vpu);
#endif

#if VIBRANTE_PDK_DECIMAL < 6000400
/**
 * @brief Registers an stmDlaSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  @param[in] func STM DLA submitter runnable function pointer.
 *  @param[in] runnableId Name of DLA submitter runnable provided to the STM compiler.
 *  @param[in] userdata Pointer to any data needed by the runnable.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_GENERIC if some other error occured.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterDlaSubmitter(stmDlaSubmitter_t func, const char* const runnableId, void* userdata);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000200
/**
 * @brief Registers an stmCudlaSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  @remark STM cuDLA hybrid Support is only enabled with the 6.0.2.0 PDK, and will fail at the link stage otherwise.
 *
 *  @param[in] func STM cuDLA submitter runnable function pointer.
 *  @param[in] runnableId Name of cuDLA submitter runnable provided to the STM compiler.
 *  @param[in] userdata Pointer to any data needed by the runnable.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_GENERIC if some other error occured.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterCuDlaSubmitter(stmCuDlaSubmitter_t func, const char* const runnableId, void* userdata);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000600
/**
 * @brief Registers an stmLdcSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  @param[in] func STM LDC submitter runnable function pointer.
 *  @param[in] runnableId Name of LDC submitter runnable provided to the STM compiler.
 *  @param[in] userdata Pointer to any data needed by the runnable.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_GENERIC if some other error occured.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterLdcSubmitter(stmLdcSubmitter_t func, const char* const runnableId, void* userdata);

/**
 * @brief Registers an stmNv2DSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  @param[in] func STM NV2D submitter runnable function pointer.
 *  @param[in] runnableId Name of NV2D submitter runnable provided to the STM compiler.
 *  @param[in] userdata Pointer to any data needed by the runnable.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_GENERIC if some other error occured.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterNv2DSubmitter(stmNv2DSubmitter_t func, const char* const runnableId, void* userdata);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000400
/**
 * @brief Registers an stmCudlaStandaloneSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  @remark STM cuDLA standalone Support is only enabled with the 6.0.4.0 PDK, and will fail at the link stage otherwise.
 *
 *  @param[in] func STM cuDLA standalone submitter runnable function pointer.
 *  @param[in] runnableId Name of cuDLA standalone submitter runnable provided to the STM compiler.
 *  @param[in] userdata Pointer to any data needed by the runnable.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_GENERIC if some other error occured.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterCuDlaStandaloneSubmitter(stmCuDlaStandaloneSubmitter_t func, const char* const runnableId, void* userdata);
#endif

#if VIBRANTE_PDK_DECIMAL >= 6000000
/**
 * @brief Registers an stmVpuSubmitter_t function with the name provided by the user to the STM compiler.
 *
 *  @remark STM cuPVA Support is only enabled with the 6.0.0.0 PDK, and will fail at the link stage otherwise.
 *
 *  @param[in] func STM cuPVA submitter runnable function pointer.
 *  @param[in] runnableId Name of cuPVA submitter runnable provided to the STM compiler.
 *  @param[in] userdata Pointer to any data needed by the runnable.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if runnableId exceeds STM_FUNC_NAME_MAX.
 *  - STM_ERROR_GENERIC if some other error occured.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmRegisterVpuSubmitter(stmVpuSubmitter_t func, const char* const runnableId, void* userdata);
#endif

#endif

/**
 * @brief Function signature for STM schedule switch callback.
 *
 * @remark stmScheduleSwitchCallback_t functions should only contain some CPU work.
 * This function will be called once per hyperepoch for each client.
 */
typedef void (*stmScheduleSwitchCallback_t)(uint16_t startScheduleId, uint16_t hyperepochId, void* userdata);

/**
 * @brief Registers a callback function with a client to be invoked during a schedule switch. Before this client
 * starts running, the callback function will be invoked.
 *
 * @remark This API can only be called once per client; doing so multiple times will result in an error.
 *
 * @param[in] func The callback function to be executed.
 * @param[in] userdata Optional pointer to any data needed by the callback.
 *
 * @return stmErrorCode_t, the completion code of the operation:
 * - STM_ERROR_BAD_PARAMETER if a call back function has already been registered with this client.
 * - STM_ERROR_GENERIC if some other error occured.
 * - STM_SUCCESS
 */
STM_API stmErrorCode_t stmRegisterCallBack(stmScheduleSwitchCallback_t func, void* userdata);

/** @brief Yield to STM scheduler, which will schedule all registered runnables in the STM schedule periodically until
 * completion. This function will not return until a runnable calls stmExitScheduler() or the number of epochs specified
 * in the STM master process have completed.
 *
 *  @remark All runnables and resources need to be registered prior to entering the schedule. This API will only begin
 * scheduling work after all STM clients have started. This API can only be called once per call to stmClientInit();
 * doing so multiple times will cause undefined behavior.
 *
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_TIMEOUT if any fence timed out.
 *  - STM_ERROR_GENERIC if there was another error.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmEnterScheduler(void);

/** @brief Get runtime information about execution
 *
 *  @remark Must be called from within a CPU runnable
 *
 *  @param[out] info Pointer to stmRunnableInfo_t whose fields will be populated
 *
 *  @return stmErrorCode_t, the completion code of the operation:
 *  - STM_ERROR_BAD_PARAMETER if info is NULL.
 *  - STM_ERROR_NOT_FOUND if the current STM thread could not be found.
 *  - STM_ERROR_INVALID_STATE if the requisite information could not be obtained.
 *  - STM_SUCCESS otherwise.
 */
STM_API stmErrorCode_t stmGetRuntimeInfo(stmRunnableInfo_t* info);

/** @brief Return from stmEnterScheduler().
 *
 *  @remark Called from within a runnable; causes all clients to return from their respective calls to stmEnterScheduler()
 *  at the next epoch boundary. Only needs to be called from one runnable in one STM client; subsequent calls are ignored.
 *  @return stmErrorCode_t, the completion code of the operation:
 *  -STM_SUCCESS if successful.
 *  -STM_ERROR_GENERIC if the request to set the state to exit failed.
 *  -STM_ERROR_BAD_PARAMETER if the request to set the state to exit has already been triggered.
 *  -STM_ERROR_NOT_INITIALIZED if stmClientInit() has not been called, or stmClientExit() has already been called.
 */
STM_API stmErrorCode_t stmExitScheduler(void);

/**
 * @brief Cleans up STM client context. No STM APIs can be called after this.
 *
 * @remark This API can only be called once per call to stmClientInit(); doing so multiple times will cause undefined  behavior.
 **/
STM_API void stmClientExit(void);

#ifdef __cplusplus
}
#endif

#endif
