////////////////////////////////////////////////////////////////////////////////
// This code contains NVIDIA Confidential Information and is disclosed
// under the Mutual Non-Disclosure Agreement.
//
// Notice
// ALL NVIDIA DESIGN SPECIFICATIONS AND CODE ("MATERIALS") ARE PROVIDED "AS IS"
// NVIDIA MAKES NO REPRESENTATIONS, WARRANTIES, EXPRESSED, IMPLIED, STATUTORY,
// OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ANY
// IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// NVIDIA Corporation assumes no responsibility for the consequences of use of
// such information or for any infringement of patents or other rights of third
// parties that may result from its use. No license is granted by implication or
// otherwise under any patent or patent rights of NVIDIA Corporation. No third
// party distribution is allowed unless expressly authorized by NVIDIA.  Details
// are subject to change without notice. This code supersedes and replaces all
// information previously supplied. NVIDIA Corporation products are not
// authorized for use as critical components in life support devices or systems
// without express written approval of NVIDIA Corporation.
//
// Copyright (c) 2022-2024 NVIDIA Corporation. All rights reserved.
//
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and any
// modifications thereto. Any use, reproduction, disclosure or distribution of
// this software and related documentation without an express license agreement
// from NVIDIA Corporation is strictly prohibited.
//
////////////////////////////////////////////////////////////////////////////////
#ifndef DW_SENSORS_RADAR_RADARTYPES_H_
#define DW_SENSORS_RADAR_RADARTYPES_H_
// Generated by dwProto from radar_types.proto DO NOT EDIT BY HAND!
// See //3rdparty/shared/dwproto/README.md for more information

#include <dw/core/base/Types.h>

#include <dw/sensors/radar/RadarScan.h>
#include <dw/sensors/codecs/SensorInfo.h>

#ifdef __cplusplus
extern "C" {
#endif

// Max seat numbers per row
#define DW_SENSOR_RADAR_MAX_SEATS_NUMS_PER_ROW 3U
// Max footwell numbers per row
#define DW_SENSOR_RADAR_MAX_FOOTWELLS_NUMS_PER_ROW 3U
// Max rows for seats or footwells
#define DW_SENSOR_RADAR_MAX_ROWS 3U
// Index for first row for seats or footwells from front to end
#define DW_SENSOR_RADAR_FIRST_ROW 0U
// Index for second row for seats or footwells from front to end
#define DW_SENSOR_RADAR_SECOND_ROW 1U
// Index for third row for seats or footwells from front to end
#define DW_SENSOR_RADAR_THIRD_ROW 2U
// Index for left column for seats or footwells
#define DW_SENSOR_RADAR_LEFT 0U
// Index for mid column for seats or footwells
#define DW_SENSOR_RADAR_MID 1U
// Index for right column for seats or footwells
#define DW_SENSOR_RADAR_RIGHT 2U

/// Defines the range of radar return
typedef enum dwRadarRange {
    /// Short Range
    DW_RADAR_RANGE_SHORT = 0,

    /// Medium Range
    DW_RADAR_RANGE_MEDIUM = 1,

    /// Long Range
    DW_RADAR_RANGE_LONG = 2,

    /// Unknown Range
    DW_RADAR_RANGE_UNKNOWN = 3,

    /// Count
    DW_RADAR_RANGE_COUNT = 4,
} dwRadarRange;

/// Defines the type of radar return
typedef enum dwRadarReturnType {
    /// Raw detection
    DW_RADAR_RETURN_TYPE_DETECTION = 0,

    /// Processed tracker output
    DW_RADAR_RETURN_TYPE_TRACK = 1,

    /// Sensor status information
    DW_RADAR_RETURN_TYPE_STATUS = 2,

    /// Sensor classifier information
    DW_RADAR_RETURN_TYPE_CLASSIFIER = 3,

    /// Count
    DW_RADAR_RETURN_TYPE_COUNT = 4,
} dwRadarReturnType;

/// Defines the dynamic state of the radar return
typedef enum dwRadarDynamicState {
    /// Moving
    DW_RADAR_DYNAMIC_STATE_MOVING = 0,

    /// Stationary
    DW_RADAR_DYNAMIC_STATE_STATIONARY = 1,

    /// Oncoming
    DW_RADAR_DYNAMIC_STATE_ONCOMING = 2,

    /// Cross-traffic
    DW_RADAR_DYNAMIC_STATE_CROSS_TRAFFIC = 3,

    /// Stopped (was moving, now stationary)
    DW_RADAR_DYNAMIC_STATE_STOPPED = 4,

    /// Unknown
    DW_RADAR_DYNAMIC_STATE_UNKNOWN = 5,
} dwRadarDynamicState;

/// Defines Occupancy status, itâ€™s used to indicate if the seat/footwell occupied or not
typedef enum dwRadarOccupancyStatus {
    /// Occupancy status not monitored
    DW_RADAR_OCCUPANCY_STATUS_NOT_MONITORED = 0,

    /// Occupancy status unknown
    DW_RADAR_OCCUPANCY_STATUS_UNKNOWN = 1,

    /// Occupancy status empty
    DW_RADAR_OCCUPANCY_STATUS_EMPTY = 2,

    /// Occupancy status occupied
    DW_RADAR_OCCUPANCY_STATUS_OCCUPIED = 3,
} dwRadarOccupancyStatus;

/// CPD class status, used to determine whether the occupant is a child or adult.
typedef enum dwRadarCPDCLASSStatus {
    /// CPD class status not monitored
    DW_RADAR_CPDCLASS_STATUS_NOT_MONITORED = 0,

    /// CPD class status unknown
    DW_RADAR_CPDCLASS_STATUS_UNKNOWN = 1,

    /// CPD class status adult
    DW_RADAR_CPDCLASS_STATUS_ADULT = 2,

    /// CPD class status child
    DW_RADAR_CPDCLASS_STATUS_CHILD = 3,
} dwRadarCPDCLASSStatus;

// CPD NHLSClass, used to determine there is a human or non human living subject
typedef enum dwRadarCPDNHLSCLASSStatus {
    /// CPD NHLS class status not monitored
    DW_RADAR_CPDNHLSCLASS_STATUS_NOT_MONITORED = 0,

    /// CPD NHLS class status unknown
    DW_RADAR_CPDNHLSCLASS_STATUS_UNKNOWN = 1,

    /// CPD NHLS class status human living subject
    DW_RADAR_CPDNHLSCLASS_STATUS_HLS = 2,

    /// CPD NHLS class status non human living subject
    DW_RADAR_CPDNHLSCLASS_STATUS_NHLS = 3,
} dwRadarCPDNHLSCLASSStatus;

/// Defines the type of scan (combination of return type & range)
typedef struct dwRadarScanType
{
    /// Type of radar return
    dwRadarReturnType returnType;

    /// Scan range
    dwRadarRange range;
} dwRadarScanType;

// The structs below are serialized in binary and the layout is assummed to be packed
#pragma pack(push, 1)

/// Defines the return structure for a raw radar detection in sensor coordinates.
/// The Radar Coordinate System is centered at the geometric center of the
/// radar's receptor. The x-axis points in sensing direction. The y-axis points
/// in the direction of the connector / plug and the z-axis is oriented such that
/// it completes an orthogonal right-handed coordinate system.
/// For further information, please refer to the following link:
/// https://developer.nvidia.com/docs/drive/driveworks/latest/nvsdk_dw_html/dwx_coordinate_systems.html
typedef struct dwRadarDetection
{
    /// X-position (m), with elevation assumed to be 0
    /// note: x = radius * std::cos(azimuth)
    float32_t x;

    /// Y-position (m), with elevation assumed to be 0
    /// note: y = radius * std::sin(azimuth)
    float32_t y;

    /// X-component (m/s) of the velocity in the azimuth direction, with elevation assumed to be 0
    /// note: partial velocity, vx = radial_vel * std::cos(azimuth)
    float32_t Vx;

    /// Y-component (m/s) of the velocity in the azimuth direction, with elevation assumed to be 0
    /// note: partial velocity, vy = radial_vel * std::sin(azimuth)
    float32_t Vy;

    /// Azimuth angle (radians)
    float32_t azimuth;

    /// Radial distance (m)
    float32_t radius;

    /// Radial velocity (m/s)
    float32_t radialVelocity;

    /// Reflection amplitude (dB)
    float32_t rcs;

    /// Angle of elevation (radians)
    float32_t elevationAngle;

    /// Indicates validity of the elevation angle
    bool elevationValidity;

    /// Signal to noise ratio (dBr)
    float32_t SNR;
} dwRadarDetection;

#pragma pack(pop)

// The structs below are serialized in binary and the layout is assummed to be packed
#pragma pack(push, 1)

/// Defines the track which the radar provides.
typedef struct dwRadarTrack
{
    /// Radar-provided track id
    uint32_t id;

    /// Age of tracked object (in scans)
    uint32_t age;

    /// Confidence of object existence (range: 0-1);
    float32_t confidence;

    /// Dynamic state of the object
    dwRadarDynamicState dynamicState;

    /// X-position (m)
    float32_t x;

    /// Y-position (m)
    float32_t y;

    /// Z-position (m)
    float32_t z;

    /// X-component (m/s) of the velocity
    float32_t Vx;

    /// Y-component (m/s) of the velocity
    float32_t Vy;

    /// X-component (m/s^2) of the acceleration
    float32_t Ax;

    /// Y-component (m/s^2) of the aceleration
    float32_t Ay;

    /// Azimuth angle (radians)
    float32_t azimuth;

    /// Rate of change of azimuth angle (radians/s)
    float32_t azimuthRate;

    /// Radial distance (m)
    float32_t radius;

    /// Radial velocity (m/s)
    float32_t radialVelocity;

    /// Radial acceleration (m/s^2)
    float32_t radialAcceleration;

    /// Compensated reflection amplitude (dB)
    float32_t rcs;

    /// Indicates validity of z position
    bool elevationValid;
} dwRadarTrack;

#pragma pack(pop)

/// Defines the return structure for sensor status messages
typedef struct dwRadarStatus
{
    /// X-position (m) of sensor mounting in AUTOSAR-coordinates from CoG
    /// Estimated radar position/orientation as reported by the radar,
    /// refer to Radar spec for the coordinate system defintion.
    /// [optional: might not be populated if radar is not supporting estimation]
    float32_t x;

    /// Y-position (m) of sensor mounting in AUTOSAR-coordinates from CoG
    /// Estimated radar position/orientation as reported by the radar,
    /// refer to Radar spec for the coordinate system defintion.
    /// [optional: might not be populated if radar is not supporting estimation]
    float32_t y;

    /// Z-position (m) of sensor mounting in AUTOSAR-coordinates from CoG
    /// Estimated radar position/orientation as reported by the radar,
    /// refer to Radar spec for the coordinate system defintion.
    /// [optional: might not be populated if radar is not supporting estimation]
    float32_t z;

    /// Yaw angle of sensor (radians)
    float32_t yaw;

    /// Pitch angle of sensor (radians)
    float32_t pitch;

    /// Roll angle of sensor (radians)
    float32_t roll;

    /// Deviation of azimuth angle for returns (radians)
    /// This is the deviation of the measured azimuth from what would be
    /// expected based on the geometric boresight of the sensor.
    float32_t azimuthDeviation[DW_RADAR_RANGE_COUNT];

    /// Deviation of elevation angle for returns (radians)
    /// This is the deviation of the elevation azimuth from what would be
    /// expected based on the geometric boresight of the sensor.
    float32_t elevationDeviation[DW_RADAR_RANGE_COUNT];

    /// Indicates if the sensor is aligned
    bool sensorAligned;

    /// Indicates if this is OK
    bool sensorOK;

    /// Indicates if the sensor is disturbed due to interference
    bool sensorDisturbed;

    /// Indicates if the sensor is blocked
    bool sensorBlock;
} dwRadarStatus;

/// Defines the structure for reporting current vehicle dynamics state
typedef struct dwRadarVehicleState
{
    /// Longitudinal velocity (m/s)
    float32_t velocity;

    /// Longitudinal acceleration (m/s^2)
    float32_t acceleration;

    /// Lateral acceleration (m/s^2)
    float32_t lateralAcceleration;

    /// Yaw rate (radians/s)
    float32_t yawRate;
} dwRadarVehicleState;

/// Defines the structure for reporting sensor mount position
typedef struct dwRadarMountPosition
{
    /// Id of the sensor (vendor-specific)
    uint32_t sensorId;

    /// Radar position
    dwTransformation3f radarPosition;

    /// Size of wheel-base (m)
    float32_t wheelbase;

    /// Damping of radome (db)
    float32_t damping;

    /// Indicates if the sensor is reversed from its default orientation
    bool isReversed;
} dwRadarMountPosition;

/// Defines the properties of the radar
typedef struct dwRadarProperties
{
    /// Indicates whether decoding is enabled
    uint8_t isDecodingOn;

    /// Number of supported scan types
    uint32_t numScanTypes;

    /// Enumerates the types of scans supported by the radar
    uint32_t supportedScanTypes[DW_RADAR_RETURN_TYPE_COUNT][DW_RADAR_RANGE_COUNT];

    /// # of packets per scan (Note: will be deprecated soon)
    uint32_t packetsPerScan;

    /// Max # of returns in any given scan
    uint32_t maxReturnsPerScan[DW_RADAR_RETURN_TYPE_COUNT][DW_RADAR_RANGE_COUNT];

    /// Number of scans (of a particular type) per second.
    /// In case scan rate differ between scans, this number is the maximum
    /// amongst all scan types
    uint32_t scansPerSecond;

    /// Number of input odometry packets per second
    uint32_t inputPacketsPerSecond;

    /// Indicates whether the sensor is simulated
    bool isSimulation;

    /// Radar model of the current radar
    dwRadarModel radarModel;

    /// RadarSSI size in bytes, so user know the memory to be allocated for dwRadarScan.radarSSI
    size_t radarSSISizeInBytes;

    /// Number of packets in any given scan
    size_t numPacketsPerScan[DW_RADAR_RETURN_TYPE_COUNT][DW_RADAR_RANGE_COUNT];

    /// Structure holding sensor information including firmware version and serial number etc.
    dwSensorInformation sensorInfo;
} dwRadarProperties;

/// Define Validity info for dwRadarOccupancyResult
typedef struct dwRadarOccupancyResultValidity
{
    /// validity info for dwRadarOccupancyResult.status
    bool statusValidity;

    /// validity info for dwRadarOccupancyResult.confidence
    bool confidenceValidity;
} dwRadarOccupancyResultValidity;

/// Define Occupancy result for a seat or footwell
typedef struct dwRadarOccupancyResult
{
    /// Radar Occupancy status for seat or footwell
    dwRadarOccupancyStatus status;

    /// The confidence of Radar Occupancy status(range: 0-1)
    float32_t confidence;
} dwRadarOccupancyResult;

/// Define Occupancy results for all the seats and footwells in a car
typedef struct dwRadarOccupancyResults
{
    /// validity info for seats field
    dwRadarOccupancyResultValidity seatsValidity[DW_SENSOR_RADAR_MAX_ROWS][DW_SENSOR_RADAR_MAX_SEATS_NUMS_PER_ROW];

    /// validity info for footwells field
    dwRadarOccupancyResultValidity footwellsValidity[DW_SENSOR_RADAR_MAX_ROWS][DW_SENSOR_RADAR_MAX_FOOTWELLS_NUMS_PER_ROW];

    /// 2D array to mimic the actual representation of rows and columns for seats, for example
    /// seats[DW_SENSOR_RADAR_FIRST_ROW][DW_SENSOR_RADAR_LEFT] 1st row left seat,
    /// seats[DW_SENSOR_RADAR_SECOND_ROW][DW_SENSOR_RADAR_RIGHT] 2nd row right seat
    dwRadarOccupancyResult seats[DW_SENSOR_RADAR_MAX_ROWS][DW_SENSOR_RADAR_MAX_SEATS_NUMS_PER_ROW];

    /// 2D array to mimic the actual representation of rows and columns for footwells, for example
    /// footwells[DW_SENSOR_RADAR_FIRST_ROW][DW_SENSOR_RADAR_LEFT] 1st row left footwell,
    /// footwells[DW_SENSOR_RADAR_SECOND_ROW][DW_SENSOR_RADAR_RIGHT] 2nd row right footwell
    dwRadarOccupancyResult footwells[DW_SENSOR_RADAR_MAX_ROWS][DW_SENSOR_RADAR_MAX_FOOTWELLS_NUMS_PER_ROW];
} dwRadarOccupancyResults;

/// Define Validity info for dwRadarCPDCLASSResult
typedef struct dwRadarCPDCLASSResultValidity
{
    /// validity info for dwRadarCPDCLASSResult.status
    bool statusValidity;

    /// validity info for dwRadarCPDCLASSResult.confidence
    bool confidenceValidity;
} dwRadarCPDCLASSResultValidity;

/// Define CPD Class result for a seat or footwell
typedef struct dwRadarCPDCLASSResult
{
    /// Radar CPD class status for seat or footwell
    dwRadarCPDCLASSStatus status;

    /// The confidence of Radar CPD class status(range: 0-1)
    float32_t confidence;
} dwRadarCPDCLASSResult;

/// Define CPD class results for all the seats and footwells in a car
typedef struct dwRadarCPDCLASSResults
{
    /// validity info for seats field
    dwRadarCPDCLASSResultValidity seatsValidity[DW_SENSOR_RADAR_MAX_ROWS][DW_SENSOR_RADAR_MAX_SEATS_NUMS_PER_ROW];

    /// validity info for footwells field
    dwRadarCPDCLASSResultValidity footwellsValidity[DW_SENSOR_RADAR_MAX_ROWS][DW_SENSOR_RADAR_MAX_FOOTWELLS_NUMS_PER_ROW];

    /// 2D array to mimic the actual representation of rows and columns for seats, for example
    /// seats[DW_SENSOR_RADAR_FIRST_ROW][DW_SENSOR_RADAR_LEFT] 1st row left seat,
    /// seats[DW_SENSOR_RADAR_SECOND_ROW][DW_SENSOR_RADAR_RIGHT] 2nd row right seat
    dwRadarCPDCLASSResult seats[DW_SENSOR_RADAR_MAX_ROWS][DW_SENSOR_RADAR_MAX_SEATS_NUMS_PER_ROW];

    /// 2D array to mimic the actual representation of rows and columns for footwells, for example
    /// footwells[DW_SENSOR_RADAR_FIRST_ROW][DW_SENSOR_RADAR_LEFT] 1st row left footwell,
    /// footwells[DW_SENSOR_RADAR_SECOND_ROW][DW_SENSOR_RADAR_RIGHT] 2nd row right footwell
    dwRadarCPDCLASSResult footwells[DW_SENSOR_RADAR_MAX_ROWS][DW_SENSOR_RADAR_MAX_FOOTWELLS_NUMS_PER_ROW];
} dwRadarCPDCLASSResults;

/// Define Validity info for dwRadarCPDNHLSCLASSResult
typedef struct dwRadarCPDNHLSCLASSResultValidity
{
    /// validity info for dwRadarCPDNHLSCLASSResult.status
    bool statusValidity;

    /// validity info for dwRadarCPDNHLSCLASSResult.confidence
    bool confidenceValidity;
} dwRadarCPDNHLSCLASSResultValidity;

/// Define CPD NHLSClass result for a seat or footwell
typedef struct dwRadarCPDNHLSCLASSResult
{
    /// Radar CPD class status for seat or footwell
    dwRadarCPDNHLSCLASSStatus status;

    /// The confidence of Radar CPDNHLS class status(range: 0-1)
    float32_t confidence;
} dwRadarCPDNHLSCLASSResult;

/// Define CPD NHLS class results for all the seats and footwells in a car
typedef struct dwRadarCPDNHLSCLASSResults
{
    /// validity info for seats field
    dwRadarCPDNHLSCLASSResultValidity seatsValidity[DW_SENSOR_RADAR_MAX_ROWS][DW_SENSOR_RADAR_MAX_SEATS_NUMS_PER_ROW];

    /// validity info for footwells field
    dwRadarCPDNHLSCLASSResultValidity footwellsValidity[DW_SENSOR_RADAR_MAX_ROWS][DW_SENSOR_RADAR_MAX_FOOTWELLS_NUMS_PER_ROW];

    /// 2D array to mimic the actual representation of rows and columns for seats, for example
    /// seats[DW_SENSOR_RADAR_FIRST_ROW][DW_SENSOR_RADAR_LEFT] 1st row left seat,
    /// seats[DW_SENSOR_RADAR_SECOND_ROW][DW_SENSOR_RADAR_RIGHT] 2nd row right seat
    dwRadarCPDNHLSCLASSResult seats[DW_SENSOR_RADAR_MAX_ROWS][DW_SENSOR_RADAR_MAX_SEATS_NUMS_PER_ROW];

    /// 2D array to mimic the actual representation of rows and columns for footwells, for example
    /// footwells[DW_SENSOR_RADAR_FIRST_ROW][DW_SENSOR_RADAR_LEFT] 1st row left footwell,
    /// footwells[DW_SENSOR_RADAR_SECOND_ROW][DW_SENSOR_RADAR_RIGHT] 2nd row right footwell
    dwRadarCPDNHLSCLASSResult footwells[DW_SENSOR_RADAR_MAX_ROWS][DW_SENSOR_RADAR_MAX_FOOTWELLS_NUMS_PER_ROW];
} dwRadarCPDNHLSCLASSResults;

/// Define Radar classifier result including Occupancy results, CPD class results and CPD NHLSClass Results
typedef struct dwRadarClassifierResult
{
    /// This is used to determine whether there is a valid occupant in a seat or not.
    dwRadarOccupancyResults occupancyResults;

    /// This is used to determine whether the occupant is a child or adult
    dwRadarCPDCLASSResults cpdClassResults;

    /// This is used to determine whether there is a human or non human living subject in the seat.
    dwRadarCPDNHLSCLASSResults cpdNHLSClassResults;
} dwRadarClassifierResult;

#ifdef __cplusplus
}
#endif

#endif // DW_SENSORS_RADAR_RADARTYPES_H_
