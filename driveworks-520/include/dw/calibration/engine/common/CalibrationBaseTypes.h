////////////////////////////////////////////////////////////////////////////////
// This code contains NVIDIA Confidential Information and is disclosed
// under the Mutual Non-Disclosure Agreement.
//
// Notice
// ALL NVIDIA DESIGN SPECIFICATIONS AND CODE ("MATERIALS") ARE PROVIDED "AS IS"
// NVIDIA MAKES NO REPRESENTATIONS, WARRANTIES, EXPRESSED, IMPLIED, STATUTORY,
// OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ANY
// IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// NVIDIA Corporation assumes no responsibility for the consequences of use of
// such information or for any infringement of patents or other rights of third
// parties that may result from its use. No license is granted by implication or
// otherwise under any patent or patent rights of NVIDIA Corporation. No third
// party distribution is allowed unless expressly authorized by NVIDIA.  Details
// are subject to change without notice. This code supersedes and replaces all
// information previously supplied. NVIDIA Corporation products are not
// authorized for use as critical components in life support devices or systems
// without express written approval of NVIDIA Corporation.
//
// Copyright (c) 2016-2024 NVIDIA Corporation. All rights reserved.
//
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and any
// modifications thereto. Any use, reproduction, disclosure or distribution of
// this software and related documentation without an express license agreement
// from NVIDIA Corporation is strictly prohibited.
//
////////////////////////////////////////////////////////////////////////////////
#ifndef DW_CALIBRATION_ENGINE_COMMON_CALIBRATIONBASETYPES_H_
#define DW_CALIBRATION_ENGINE_COMMON_CALIBRATIONBASETYPES_H_
// Generated by dwProto from calibration_base_types.proto DO NOT EDIT BY HAND!
// See //3rdparty/shared/dwproto/README.md for more information

/**
 * @file
 * <b>NVIDIA DriveWorks API: Calibration</b>
 *
 * @b Description: Contains fundamental types associated with Calibration
 */

/**
 * @defgroup calibration_types_group Calibration Types
 * @ingroup calibration_group
 *
 * @brief Fundamental types associated with Calibration
 *
 * @{
 */

#include <dw/core/base/Exports.h>
#include <dw/core/base/Types.h>

#ifdef __cplusplus
extern "C" {
#endif

/// Defines the maximum length of a signal name
#define DW_CALIBRATION_STATE_MAX_SIGNAL_NAME_STRING_LENGTH 32U
/// Defines the maximum length of a signal units
#define DW_CALIBRATION_STATE_MAX_SIGNAL_UNIT_STRING_LENGTH 16U
/// Defines the maximum length of an array with signal updates
#define DW_SIGNAL_STATE_MAX_UPDATE_ARRAY_SIZE 4U
/// @brief maximal length of an array with signals
#define DW_CALIBRATION_SIGNAL_NUM_SIGNALS 13
/// @brief This defines the number of anticipated concurrent calibrations
#define DW_CALIBRATION_MAXROUTINES 64
/// Defines the maximum length of a calibration routine status string
#define DW_CALIBRATION_ROUTINE_STATUS_STRING_LENGTH 128U

/// @brief Defines the current state of an individual calibration
typedef enum dwCalibrationState {
    /// The routine hasn't accepted an estimate
    DW_CALIBRATION_STATE_NOT_ACCEPTED = 0,

    /// The routine has accepted an estimate and calibration continues
    DW_CALIBRATION_STATE_ACCEPTED = 1,

    /// The routine has failed calibration
    DW_CALIBRATION_STATE_FAILED = 2,

    /// The calibration state is invalid (e.g. when a door with a sensor is open or a mirror is moving)
    DW_CALIBRATION_STATE_INVALID = 3,
} dwCalibrationState;

/// @brief Defines signal types supported by a calibration routine.
typedef enum dwCalibrationSignal {
    /// not-specified signal (shall not be used)
    DW_CALIBRATION_SIGNAL_UNKNOWN = 0,

    /// Pose-related signals and pose components
    DW_CALIBRATION_SIGNAL_POSE_SENSOR_TO_RIG    = 1 << 1, //!< estimating a "sensor to rig" pose
    DW_CALIBRATION_SIGNAL_POSE_SENSOR_TO_SENSOR = 1 << 2, //!< estimating "sensor to sensor" poses
    DW_CALIBRATION_SIGNAL_POSE_ROLL             = 1 << 3, //!< estimating the roll component of an orientation
    DW_CALIBRATION_SIGNAL_POSE_PITCH            = 1 << 4, //!< estimating the pitch component of an orientation
    DW_CALIBRATION_SIGNAL_POSE_YAW              = 1 << 5, //!< estimating the yaw component of an orientation
    DW_CALIBRATION_SIGNAL_POSE_X                = 1 << 6, //!< estimating the x component of a translation / direction
    DW_CALIBRATION_SIGNAL_POSE_Y                = 1 << 7, //!< estimating the y component of a translation / direction
    DW_CALIBRATION_SIGNAL_POSE_Z                = 1 << 8, //!< estimating the z component of a translation / direction

    // Vehicle-related signals
    /// @deprecated The signal is not available. The enum will be deleted in next release
    DW_CALIBRATION_SIGNAL_VEHICLE_SPEED_FACTOR DW_DEPRECATED_ENUM("The signal is not available. The enum will be deleted in next release") = 1 << 9,  //!< estimating speed correction factor for CAN odometry
    DW_CALIBRATION_SIGNAL_VEHICLE_WHEEL_RADII                                                                                              = 1 << 10, //!< estimating wheel radii
    DW_CALIBRATION_SIGNAL_VEHICLE_FRONT_STEERING_OFFSET                                                                                    = 1 << 11, //!< estimating front steering offset

    /// Camera intrinsics-related signals
    DW_CALIBRATION_SIGNAL_INTRINSICS_SCALE = 1 << 12, //!< scale factor applied to angle in f-theta camera model
} dwCalibrationSignal;

/// @brief Fast-acceptance options to configure calibration routines with.
///
/// If previously accepted estimates are available, fast-acceptance is a method to reduce re-calibration times
/// in case the previous estimates can be validated with latest measurements. This option allows to configure
/// the fast-acceptance behavior of calibration routines supporting fast-acceptance
typedef enum dwCalibrationFastAcceptanceOption {
    /// Let the calibration engine decide if fast-acceptance should be used
    DW_CALIBRATION_FAST_ACCEPTANCE_DEFAULT = 0,

    /// Unconditionally enable fast-acceptance (previously accepted estimates need to be available)
    DW_CALIBRATION_FAST_ACCEPTANCE_ENABLED = 1,

    /// Unconditionally disable fast-acceptance (previously accepted estimates will not be used)
    DW_CALIBRATION_FAST_ACCEPTANCE_DISABLED = 2,
} dwCalibrationFastAcceptanceOption;

/// @brief Defines the current status of an individual calibration
typedef struct dwCalibrationStatus
{
    /// Flag indicating whether a calibration routine is running
    bool started;

    /// The current state of a calibration routine
    dwCalibrationState state;

    /// The current calibration percentage complete status. Valid percentages are in the range [0,1]
    float32_t percentageComplete;

    /// Current error bound at 3 sigma (99.7%) as estimated by the routine, same units as the signal.
    /// @note: FLT_MAX if value is not defined or not estimated
    float32_t errorBound;
} dwCalibrationStatus;

/// @brief Defines the calibration signal state
typedef struct dwCalibrationSignalState
{
    /// short name of the estimated signal (e.g. `yaw` / `sensor2rig`)
    char8_t signalName[DW_CALIBRATION_STATE_MAX_SIGNAL_NAME_STRING_LENGTH];

    /// units of the signal (e.g., `deg` / `meter`)
    char8_t signalUnit[DW_CALIBRATION_STATE_MAX_SIGNAL_UNIT_STRING_LENGTH];

    /// indicating whether this signal is currently being estimated
    bool estimating;

    /// current best estimate for this signal
    float32_t bestEstimate;

    /// Calibration status
    dwCalibrationStatus status;

    /// type of the estimated quantity
    dwCalibrationSignal signalType;

    /// value of last few raw estimates for this signal reported by signal estimators. [0] is oldest this cycle
    /// array size is equal to a number of updates this cycle
    float32_t lastUpdates[DW_SIGNAL_STATE_MAX_UPDATE_ARRAY_SIZE];
    size_t updateCount; //!< Stores the occupied/valid length of lastUpdates
} dwCalibrationSignalState;

/// @brief array of signal states
typedef struct dwCalibrationSignalStateArray
{
    // collection of the different (calibrated) signals
    dwCalibrationSignalState stateSignals[DW_CALIBRATION_SIGNAL_NUM_SIGNALS];
    size_t numSignals; //!< Stores the occupied/valid length of stateSignals
} dwCalibrationSignalStateArray;

#ifdef __cplusplus
}
#endif

/** @}
 */

#endif // DW_CALIBRATION_ENGINE_COMMON_CALIBRATIONBASETYPES_H_
