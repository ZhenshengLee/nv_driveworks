////////////////////////////////////////////////////////////////////////////////
// This code contains NVIDIA Confidential Information and is disclosed
// under the Mutual Non-Disclosure Agreement.
//
// Notice
// ALL NVIDIA DESIGN SPECIFICATIONS AND CODE ("MATERIALS") ARE PROVIDED "AS IS"
// NVIDIA MAKES NO REPRESENTATIONS, WARRANTIES, EXPRESSED, IMPLIED, STATUTORY,
// OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ANY
// IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// NVIDIA Corporation assumes no responsibility for the consequences of use of
// such information or for any infringement of patents or other rights of third
// parties that may result from its use. No license is granted by implication or
// otherwise under any patent or patent rights of NVIDIA Corporation. No third
// party distribution is allowed unless expressly authorized by NVIDIA.  Details
// are subject to change without notice. This code supersedes and replaces all
// information previously supplied. NVIDIA Corporation products are not
// authorized for use as critical components in life support devices or systems
// without express written approval of NVIDIA Corporation.
//
// Copyright (c) 2015-2024 NVIDIA Corporation. All rights reserved.
//
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and any
// modifications thereto. Any use, reproduction, disclosure or distribution of
// this software and related documentation without an express license agreement
// from NVIDIA Corporation is strictly prohibited.
//
////////////////////////////////////////////////////////////////////////////////
#ifndef DW_EGOMOTION_BASE_EGOMOTIONTYPES_H_
#define DW_EGOMOTION_BASE_EGOMOTIONTYPES_H_
// Generated by dwProto from egomotion_types.proto DO NOT EDIT BY HAND!
// See //3rdparty/shared/dwproto/README.md for more information

#include <dw/core/base/Exports.h>
#include <dw/core/base/Types.h>

#include <dw/rig/Vehicle.h>

#ifdef __cplusplus
extern "C" {
#endif

/// @brief Defines the motion models.
typedef enum dwMotionModel {
    /**
 * Given odometry information, estimates motion of the vehicle using a bicycle model.
 *
 * The following parameters are required for this model:
 * - dwEgomotionParameters
 *   - vehicle
 *     - wheelbase, mass, inertia3D, frontCorneringStiffness, rearCorneringStiffness,
 *       centerOfMassToRearAxle, wheelRadius (1), steeringWheelToSteeringMap (2),
 *       maxSteeringWheelAngle (2), frontSteeringOffset (2)
 *   - speedMeasurementType
 *
 * This model is capable of providing the following estimates:
 * - dwEgomotionResult
 *   - rotation (only around vehicle rig yaw axis, relative to initial orientation)
 *   - linearVelocity[0] and linearVelocity[1]
 *   - angularVelocity[2]
 *   - linearAcceleration[1]
 * - dwTransformation3f (with @ref dwEgomotion_computeRelativeTransformation)
 *   - motion only estimated in plane, i.e. x, y translation and yaw rotation.
 *
 * Uncertainty estimates are not supported at this time.
 *
 * - (1) if dwEgomotionParameters.speedMeasurementType == DW_EGOMOTION_REAR_WHEEL_SPEED
 */
    DW_EGOMOTION_ODOMETRY = 1 << 0,

    /**
 * Fuses odometry model with IMU measurements to estimate motion of the vehicle.
 *
 * The following parameters are required for this model:
 * - dwEgomotionParameters
 *   - vehicle
 *     - wheelRadius (1), steeringWheelToSteeringMap (2), maxSteeringWheelAngle (2),
 *       wheelbase (3, 4), mass (3, 4), centerOfMassHeight (3), inertia3D (3), centerOfMassToFrontAxle (4)
 *       rearCorneringStiffness (4)
 *   - imu2rig
 *   - speedMeasurementType
 *
 * This model is capable of providing the following estimates:
 * - dwEgomotionResult
 *   - rotation (in local vertical, local horizontal coordinate frame aligned with initial heading of vehicle)
 *   - linearVelocity[0] and linearVelocity[1]
 *   - angularVelocity
 *   - linearAcceleration
 * - dwTransformation3f (with @ref dwEgomotion_computeRelativeTransformation)
 *
 * Uncertainty estimates are provided for all state estimates listed above.
 *
 * - (1) if dwEgomotionParameters.speedMeasurementType == DW_EGOMOTION_REAR_WHEEL_SPEED
 * - (2) if dwEgomotionParameters.suspension.model == DW_EGOMOTION_SUSPENSION_TORSIONAL_SPRING_MODEL
 * - (3) if dwEgomotionParameters.lateralSlipCoefficient == 0
 */
    DW_EGOMOTION_IMU_ODOMETRY = (1 << 2) - 1,

    /**
 * Egomotion estimation based on IMU and RoV sensors (wheel encoders, steering, suspension, drive status, ...)
 * targeted for NDAS production. Not officially supported as part of DriveWorks SDK, backwards compatibility and
 * deprecation process will not be followed. See disclaimer in dw/egomotion/2.0/Egomotion2.h for more information.
 */
    DW_EGOMOTION_VEHICLE_MOTION_OBSERVER = 1 << 2,
} dwMotionModel;

/// @brief Defines motion measurements.
typedef enum dwMotionModelMeasurement {
    DW_EGOMOTION_MEASUREMENT_VELOCITY           = 0, //!< Vehicle velocity [m/s].
    DW_EGOMOTION_MEASUREMENT_STEERINGANGLE      = 1, //!< Steering angle [rad].
    DW_EGOMOTION_MEASUREMENT_STEERINGWHEELANGLE = 2, //!< Steering wheel angle [rad].
} dwMotionModelMeasurement;

/// @brief Defines speed measurement types.
typedef enum dwEgomotionSpeedMeasurementType {
    /**
 * Indicates that speed is linear speed [m/s] measured at front wheels (along steering direction).
 * Steering angle [rad] is used internally to compute longitudinal speed.
 *
 * - Positive speed corresponds to a forward motion of the vehicle.
 * - Positive steering angle corresponds to a left turn.
 *
 * @note: estimation quality is dependent on measurement accuracy, resolution and sampling rate. We recommend the following:
 * - speed signal at >=50Hz sampling rate and resolution of 0.02 m/s or higher.
 * - steering angle signal at >=50Hz sampling rate and resolution of 0.01 deg or higher.
 *
 * Provide front speed measurement and steering angle with
 * the @ref dwEgomotion_addVehicleState API where the `dwVehicleIOState` struct contains `speed`, `frontSteeringAngle`,
 * `speedTimestamp` and `steeringTimestamp` or with @ref dwEgomotion_addVehicleIOState API where at least one of
 * `dwVehicleIOSafetyState`, `dwVehicleIONonSafetyState` or `dwVehicleIOActuationFeedback` contain valid values of
 * `speed`, `frontSteeringAngle`, `speedTimestamp` and `frontSteeringTimestamp`.
 */
    DW_EGOMOTION_FRONT_SPEED = 0,

    /**
 * Indicates that speeds are angular speeds [rad/s] measured at rear wheels.
 *
 * - Positive angular speeds correspond to a forward motion of the vehicle.
 *
 * @note This mode requires valid `dwEgomotionParameters.dwVehicle.wheelRadius` otherwise incorrect
 * estimation of the longitudinal speed will be made.
 *
 * @note It is expected that both rear wheel speed measurements are not far apart in time, otherwise
 * degradation in estimation quality is expected.
 *
 * @note: estimation quality is dependent on measurement accuracy, resolution and sampling rate. We recommend the following:
 * - speed signal at >=50Hz sampling rate and resolution of 0.05 rad/s or higher.
 *
 * @note: Egomotion supports steered rear axles.
 *
 * Provide rear wheel speed measurements with the @ref dwEgomotion_addVehicleState API where the `dwVehicleIOState`
 * struct contains `wheelSpeed` and `wheelSpeedTimestamp` or with @ref dwEgomotion_addVehicleIOState API where at least one of
 * `dwVehicleIOSafetyState`, `dwVehicleIONonSafetyState` or `dwVehicleIOActuationFeedback` contain valid values of
 * `wheelSpeed` and `wheelTickTimestamp`.
 */
    DW_EGOMOTION_REAR_WHEEL_SPEED = 1,

    /**
 * Indicates that speed is linear speed [m/s] measured at rear axle center (along steering direction).
 * Rear steering angle [rad] given by dwVehicleIOState.rearWheelAngle is used internally to compute longitudinal speed.
 *
 * - Positive speed corresponds to a forward motion of the vehicle.
 * - Positive steering angle corresponds to a lateral motion towards the left at the rear axle.
 *
 * @note: estimation quality is dependent on measurement accuracy, resolution and sampling rate. We recommend the following:
 * - speed signal at >=50Hz sampling rate and resolution of 0.02 m/s or higher.
 *
 * Provide rear speed measurement with the @ref dwEgomotion_addVehicleState API where the `dwVehicleIOState` struct
 * contains `speed`, `rearWheelAngle` and `speedTimestamp` or with @ref dwEgomotion_addVehicleIOState API where at least one of
 * `dwVehicleIOSafetyState`, `dwVehicleIONonSafetyState` or `dwVehicleIOActuationFeedback` contain valid values for
 * `speed`, `rearWheelAngle` and `speedTimestamp`.
 */
    DW_EGOMOTION_REAR_SPEED = 2,
} dwEgomotionSpeedMeasurementType;

/// @brief Defines steering measurement types.
typedef enum dwEgomotionSteeringMeasurementType {
    DW_EGOMOTION_FRONT_STEERING       = 0, //!< @see dwVehicleIOState frontSteeringAngle
    DW_EGOMOTION_STEERING_WHEEL_ANGLE = 1, //!< @see dwVehicleIOState steeringWheelAngle
} dwEgomotionSteeringMeasurementType;

/// @brief Defines egomotion linear acceleration filter mode.
typedef enum dwEgomotionLinearAccelerationFilterMode {
    DW_EGOMOTION_ACC_FILTER_NO_FILTERING = 0, //!< no filtering of the output linear acceleration
    DW_EGOMOTION_ACC_FILTER_SIMPLE       = 1, //!< simple low-pass filtering of the acceleration
} dwEgomotionLinearAccelerationFilterMode;

/// @brief Defines egomotion suspension model.
typedef enum dwEgomotionSuspensionModel {
    DW_EGOMOTION_SUSPENSION_RIGID_MODEL            = 0, //!< No suspension model. Equivalent to perfectly rigid suspension.
    DW_EGOMOTION_SUSPENSION_TORSIONAL_SPRING_MODEL = 1, //!< Models suspension as single-axis damped torsional spring.
} dwEgomotionSuspensionModel;

/// @brief Defines flags that indicate validity of corresponding data in @ref dwEgomotionResult and @ref dwEgomotionUncertainty.
typedef enum dwEgomotionDataField {
    DW_EGOMOTION_ROTATION  = 1 << 0,  //!< indicates validity of rotation, @see limitations of selected @ref dwMotionModel
    DW_EGOMOTION_LIN_VEL_X = 1 << 1,  //!< indicates validity of linearVelocity[0]
    DW_EGOMOTION_LIN_VEL_Y = 1 << 2,  //!< indicates validity of linearVelocity[1]
    DW_EGOMOTION_LIN_VEL_Z = 1 << 3,  //!< indicates validity of linearVelocity[2]
    DW_EGOMOTION_ANG_VEL_X = 1 << 4,  //!< indicates validity of angularVelocity[0]
    DW_EGOMOTION_ANG_VEL_Y = 1 << 5,  //!< indicates validity of angularVelocity[1]
    DW_EGOMOTION_ANG_VEL_Z = 1 << 6,  //!< indicates validity of angularVelocity[2]
    DW_EGOMOTION_LIN_ACC_X = 1 << 7,  //!< indicates validity of linearAcceleration[0]
    DW_EGOMOTION_LIN_ACC_Y = 1 << 8,  //!< indicates validity of linearAcceleration[1]
    DW_EGOMOTION_LIN_ACC_Z = 1 << 9,  //!< indicates validity of linearAcceleration[2]
    DW_EGOMOTION_ANG_ACC_X = 1 << 10, //!< indicates validity of angularAcceleration[0]
    DW_EGOMOTION_ANG_ACC_Y = 1 << 11, //!< indicates validity of angularAcceleration[1]
    DW_EGOMOTION_ANG_ACC_Z = 1 << 12, //!< indicates validity of angularAcceleration[2]
} dwEgomotionDataField;

/// @brief Egomotion integrity levels.
///
/// Non-QM integrity levels are only applicable to vehicle platforms developed for NDAS. No guarantees are made for usage
/// of egomotion as part of non-NDAS DriveWorks SDK.
///
/// Non-QM integrity levels are only provided for select egomotion modalities.
///
/// @see dwEgomotionQuality
///
typedef enum dwEgomotionIntegrity {
    DW_EGOMOTION_INTEGRITY_INVALID  = 0, //!< Signal is invalid, do not use.
    DW_EGOMOTION_INTEGRITY_VALID_QM = 1, //!< Signal is valid without guarantees (no error bounds provided).
    DW_EGOMOTION_INTEGRITY_VALID_A  = 2, //!< Signal is valid and within error bounds with ASIL A guarantee.
    DW_EGOMOTION_INTEGRITY_VALID_B  = 3, //!< Signal is valid and within error bounds with ASIL B guarantee.
    DW_EGOMOTION_INTEGRITY_VALID_C  = 4, //!< Signal is valid and within error bounds with ASIL C guarantee.
    DW_EGOMOTION_INTEGRITY_VALID_D  = 5, //!< Signal is valid and within error bounds with ASIL D guarantee.
} dwEgomotionIntegrity;

/// @brief Defines egomotion linear acceleration filter parameters.
typedef struct dwEgomotionLinearAccelerationFilterParams
{
    /// Linear acceleration filter mode. Default (0): no filtering.
    dwEgomotionLinearAccelerationFilterMode mode;

    /// Simple filter parameters (ignored for other modes)
    float32_t accelerationFilterTimeConst;       //!< Time constant of the IMU acceleration measurements
    float32_t processNoiseStdevSpeed;            //!< Square root of continuous time process noise covariance in speed [m/s * 1/sqrt(s)]
    float32_t processNoiseStdevAcceleration;     //!< Square root of continuous time process noise covariance in acceleration [m/s^2 * 1/sqrt(s)]
    float32_t measurementNoiseStdevSpeed;        //!< Standard deviation of measurement noise in speed [m/s]
    float32_t measurementNoiseStdevAcceleration; //!< Standard deviation of measurement noise in acceleration [m/s^2]
} dwEgomotionLinearAccelerationFilterParams;

/// @brief Suspension model type and parameters.
typedef struct dwEgomotionSuspensionParameters
{
    /// Suspension model to use.
    /// If left zero-intialized, a rigid suspension system is assumed (i.e. no suspension modeling).
    dwEgomotionSuspensionModel model;

    /// Torsional spring model parameters. Used if model == DW_EGOMOTION_SUSPENSION_TORSIONAL_SPRING_MODEL.
    /// If left zero-initizialized, a default set of parameters will be used.
    ///
    /// These model parameters are suitable for a simple damped torsional spring model with external driving
    /// torque resulting from vehicle linear accelerations, described by the following ODE:
    /// \f$ I \ddot{\theta} + C \dot{\theta} + k \theta = \tau \f$
    ///
    /// where:
    /// - \f$ \theta \f$ suspension angle [rad]
    /// - I vehicle inertia around y axis [kg m^2]
    /// - C angular damping constant [J s rad^-1]
    /// - k torsion spring constant [N m rad^-1]
    /// - \f$ \tau \f$ driving torque [N m], function of linear acceleration, vehicle mass and height of center of mass.
    ///
    /// @note if selected, this model requires accurate vehicle mass, inertia and height of center of mass in the
    /// @ref dwVehicle struct provided as part of the @ref dwEgomotionParameters.
    ///
    /// Frequency at which the suspension system tends to oscillate around the pitch axis of the vehicle in the
    /// absence of an external driving force or damping [Hz].
    /// Typical passenger car suspension systems have a natural frequency in the range of [0.5, 1.5] Hz.
    /// Default value is 1.25Hz if left zero-initialized.
    float32_t torsionalSpringPitchNaturalFrequency;

    /// Level of damping relative to critical damping around the pitch axis of the vehicle [dimensionless].
    /// Typical passenger car suspension systems have a damping ratio in the range of [0.2, 0.6].
    /// Default value is 0.6 if left zero-initialized.
    float32_t torsionalSpringPitchDampingRatio;
} dwEgomotionSuspensionParameters;

/// @brief Sensor measurement noise characteristics.
typedef struct dwEgomotionSensorCharacteristics
{
    /// Expected zero mean measurement noise of the gyroscope, also known as Noise Density [deg/s/sqrt(Hz)]
    /// A default value of 0.015 [deg/s/sqrt(Hz)] will be assumed if no parameter, i.e. 0 or nan, passed
    float32_t gyroNoiseDensityDeg;

    /// Expected gyroscope drift rate in [deg/s].
    /// A default value of 0.025 [deg/s] will be assumed if no parameter, i.e. 0 or nan, passed
    float32_t gyroDriftRate;

    /// If known this value in [rad/s] shall indicate standard deviation of the expected bias range of the gyroscope sensor.
    /// Usually temperature controlled/calibrated gyroscopes vary around the mean by few tens of a radian. If 0 is given,
    /// it will be assumed the standard deviation around the bias mean is about +-0.05 [rad/s], ~ +- 3deg/s
    float32_t gyroBiasRange;

    /// Expected zero mean measurement noise of the linear accelerometer, also known as Noise Density [ug/sqrt(Hz)]
    /// A default value of 100 micro-g per sqrt(Hz) will be assumed if no parameter, i.e. 0 or nan, passed
    float32_t accNoiseDensityMicroG;

    /// If known this entry shall indicate expected sampling rate in [Hz] of the IMU sensor.
    /// A default value of 100Hz is used if no parameter passed
    float32_t imuSamplingRateHz;

    /// If known this entry shall indicate expected sampling rate in [Hz] of the odometry signals.
    /// This is used for detection of delays or missing vehicle signals (valid range: [33%, 300%] of below value).
    /// A default value of 50Hz is used if no parameter passed (valid range: [16.7Hz, 150Hz])
    float32_t odometrySamplingRateHz;

    /// CAN velocity latency in microseconds which is read from can properties in rig file.
    dwTime_t velocityLatency;

    /// CAN velocity correction factor which is read from can properties in rig file.
    /// When ` dwEgomotionParameters::speedMeasurementType == DW_EGOMOTION_FRONT_SPEED or DW_EGOMOTION_REAR_SPEED`
    /// then received speed measurements are multiplied by this factor to obtain (approximately) true
    /// vehicle speed, e.g. due to non-nominal wheel diameters.
    /// @note A default value of 1 is assumed if no parameter is passed
    float32_t velocityFactor;
} dwEgomotionSensorCharacteristics;

/// @brief Holds initialization parameters for the Egomotion module.
typedef struct dwEgomotionParameters
{
    /// Vehicle parameters to setup the model.
    /// @note The validity of the parameters will be verified at initialization time and an error will be
    ///       returned back if vehicle parameters are found to be not plausible.
    dwVehicle vehicle;

    /// Lateral slip coefficient [rad*s^2/m].
    /// Used in linear function mapping lateral acceleration [m/s^2] to slip angle [rad], such that
    /// slipAngle = lateralSlipCoefficient * lateralAcceleration.
    /// If 0, default slip coefficient of -2.83e-3 [rad*s^2/m] is used.
    /// @note only available for DW_EGOMOTION_IMU_ODOMETRY motion model. Ignored when DW_EGOMOTION_ODOMETRY is used.
    /// @deprecated Deriving lateral slip coefficient from vehicle parameters, unless this parameter is non-zero.
    DW_DEPRECATED("Deriving lateral slip coefficient from vehicle parameters, unless this parameter is non-zero.")
    float32_t lateralSlipCoefficient;

    /// IMU extrinsics. Transformation from the IMU coordinate system to the vehicle rig coordinate system.
    /// @note the quality of the estimated motion is highly depended on the accuracy of the extrinsics.
    dwTransformation3f imu2rig;

    /// Specifies the motion model to be used for pose estimation.
    dwMotionModel motionModel;

    /// When enabled, initial rotation will be estimated from accelerometer measurements.
    /// When disabled, initial rotation is assumed to be identity, i.e. vehicle standing on flat, horizontal ground.
    /// @note only available for DW_EGOMOTION_IMU_ODOMETRY motion model. Ignored when DW_EGOMOTION_ODOMETRY is used.
    bool estimateInitialOrientation;

    /// Automatically update state estimation.
    /// In general to update motion estimation, a call to @ref dwEgomotion_update is required.
    /// When automaticUpdate is set, the motion estimation update is triggered by the addition of new
    /// sensor measurements. The exact update timestamp is dependent on the sensor type and motion model
    /// implementation.
    /// @note when the automatic update is active, @ref dwEgomotion_update will not update the filter state
    /// and throw a `DW_NOT_SUPPORTED` exception instead.
    bool automaticUpdate;

    /// Number of state estimates to keep in the history (if 0 specified default of 1000 is used).
    /// Also known as the capacity of the history.
    /// Any call to @ref dwEgomotion_update, or automatic update, adds an estimate into the history.
    uint32_t historySize;

    /// Initial gyroscope biases, if known at initialization time. Gyroscope biases are estimated internally
    /// at run-time, however it can be beneficial if the filter is initialized with already known biases.
    /// If unknown, leave biases zero-initialized.
    float32_t gyroscopeBias[3];

    /// Sensor parameters, containing information about sensor characteristics.
    /// If the struct is zero initialized, default assumptions about sensor parameters are made.
    /// @see dwEgomotionSensorCharacteristics
    dwEgomotionSensorCharacteristics sensorParameters;

    /// Defines which velocity readings from `dwVehicleIOState` shall be used for egomotion estimation
    dwEgomotionSpeedMeasurementType speedMeasurementType;

    /// Defines which steering readings from `dwVehicleIOState` shall be used for egomotion estimation
    dwEgomotionSteeringMeasurementType steeringMeasurementType;

    /// Linear acceleration filter parameters
    /// @note only available for DW_EGOMOTION_IMU_ODOMETRY motion model. Ignored when other motion models are used.
    dwEgomotionLinearAccelerationFilterParams linearAccelerationFilterParameters;

    /// Suspension model parameters.
    /// The model is used internally to compensate for vehicle body rotation due to acceleration and resulting
    /// rotational suspension effects.
    /// If the struct is zero initialized, suspension will not be modeled and accounted for.
    /// @note only available for DW_EGOMOTION_IMU_ODOMETRY motion model. Ignored when other motion models are used.
    dwEgomotionSuspensionParameters suspension;
} dwEgomotionParameters;

/// @brief Egomotion quality: integrity and error bounds.
///
/// Egomotion provides (conservative) error bounds on its signals by leveraging an extensive monitoring framework and
/// quantifying the impact of any input or internal error on its output. Not all egomotion modalities support this.
///
/// Lower and upper error bounds are given relative to the estimated quantity and only valid if status indicates ASIL
/// level. Absolute angular quantities are subject to [-PI, PI] limits and error bounds do not wrap around.
///
/// For example, linear velocity upper and lower bounds of +1 m/s, -2 m/s respectively indicate that the true velocity
/// is within this range from the current estimate, with corresponding integrity. If the velocity estimated by egomotion
/// is 10 m/s, the bounds translate to a guarantee that the true velocity is between 8 and 11 m/s. In other words,
/// the velocity is at most under estimated by 10/11=~9%, or over estimated by 10/8=25%.
///
typedef struct dwEgomotionQuality
{
    float32_t upper;             //!< Error bound upper limit.
    float32_t lower;             //!< Error bound lower limit.
    dwEgomotionIntegrity status; //!< Integrity of signal and its error bound.
} dwEgomotionQuality;

/// @brief Quality of instantaneous state estimate.
/// @see dwEgomotionResult
typedef struct dwEgomotionResultQuality
{
    dwEgomotionQuality rotation[2];            //!< Attitude (roll, pitch).
    dwEgomotionQuality linearVelocity[3];      //!< Linear velocity in body frame.
    dwEgomotionQuality angularVelocity[3];     //!< Rotation speed in body frame.
    dwEgomotionQuality linearAcceleration[3];  //!< Linear acceleration in body frame.
    dwEgomotionQuality angularAcceleration[3]; //!< Angular acceleration in body frame.
} dwEgomotionResultQuality;

/// @brief Instantaneous state estimate.
/// @note Validity of data fields indicated by flags in @ref dwEgomotionResultQuality
typedef struct dwEgomotionResult
{
    dwQuaternionf rotation;           //!< Attitude represented as quaternion.
    dwTime_t timestamp;               //!< Timestamp of state estimate [us].
    float32_t linearVelocity[3];      //!< Linear velocity in body frame [m/s].
    float32_t angularVelocity[3];     //!< Angular velocity in body frame [rad/s].
    float32_t linearAcceleration[3];  //!< Linear acceleration in body frame [m/s^2].
    float32_t angularAcceleration[3]; //!< Angular acceleration in body frame [rad/s^2].
    dwEgomotionResultQuality quality; //!< Signal validities and their error bounds.
    int32_t validFlags;               //!< Bitwise combination of dwEgomotionDataField flags. Deprecation notice: will be removed.
} dwEgomotionResult;

/// @brief Instantaneous state uncertainty estimates.
///
/// Data in these fields represent the uncertainties of the corresponding fields in @ref dwEgomotionResult.
/// The uncertainties are represented as covariance matrix when appropriate, or in standard deviation
/// around the estimate otherwise. These values are provided "as is" for usage in fusion algorithms depending
/// on egomotion estimation but no accuracy claims are made (see below).
///
/// @note The uncertainties do not represent estimate accuracy, only the precision of the estimate, under
/// the classical filtering assumptions and limitation of the state and models used in internal estimators:
///   - error distributions are zero mean
///   - error distributions are Gaussian
/// Neither exactly hold in practice, at least not in all cases. Errors that do not fit the zero mean Gaussian
/// distribution might include calibration errors, model inaccuracies and limitations, input signal degradations
/// or outlier measurements. Such errors are unobservable (or the estimator would correct for them) and result in
/// biased error distributions. Covariances are therefore not a suitable signal to assess egomotion accuracy
/// (i.e. “quality”), particularly in safety-relevant context. Use @ref dwEgomotionResultQuality instead.
///
/// @note Units are identical to those used in @ref dwEgomotionResult. Units in covariance matrices
///     are squared.
///
/// @note Rotation is represented as a quaternion; however, here a 3x3 covariance of the equivalent euler
///       angles is given (order: roll, pitch, yaw) in [rad].
typedef struct dwEgomotionUncertainty
{
    dwMatrix3f rotation;             //!< Rotation covariance represented as euler angles (order: roll, pitch, yaw) in [rad^2]
    float32_t linearVelocity[3];     //!< Linear velocity std dev in body frame measured in [m/s].
    float32_t angularVelocity[3];    //!< Rotation speed std dev in body frame measured in [rad/s].
    float32_t linearAcceleration[3]; //!< Linear acceleration std dev measured in body frame in [m/s^2].
    float32_t angularAcceleration[3];
    dwTime_t timestamp; //!< Timestamp of egomotion uncertainty estimate [us].
    int64_t validFlags; //!< Bitwise combination of dwEgomotionDataField flags.
} dwEgomotionUncertainty;

/// @brief Relative transformation validity and uncertainty.
///
/// @note Covariances are provided "as is" for usage in fusion algorithms depending on egomotion estimation but
///       no accuracy claims are made. Review the disclaimer on covariances provided in @ref dwEgomotionUncertainty.
typedef struct dwEgomotionTransformationQuality
{
    dwMatrix3f rotation;                      //!< a 3x3 covariance of the rotation (order: roll, pitch, yaw) [rad]
    dwMatrix3f translation;                   //!< a 3x3 covariance of the translation (x,y,z) [m]
    bool covarianceValid;                     //!< whether the covariance estimates are provided
    dwEgomotionQuality rotationQuality[3];    //!< Rotation validities and their error bounds (order: roll, pitch, yaw)
    dwEgomotionQuality translationQuality[3]; //!< Translation validities and their error bounds (order: x, y, z)
    dwTime_t timeInterval;

    /// @deprecated valid is deprecated and will be removed. Use covarianceValid instead.
    DW_DEPRECATED("valid is deprecated and will be removed. Use covarianceValid instead.")
    bool valid; //!< indicates whether uncertainty estimates are valid or not
} dwEgomotionTransformationQuality;

#ifdef __cplusplus
}
#endif

#endif // DW_EGOMOTION_BASE_EGOMOTIONTYPES_H_
