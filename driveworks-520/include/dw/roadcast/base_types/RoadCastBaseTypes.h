////////////////////////////////////////////////////////////////////////////////
// This code contains NVIDIA Confidential Information and is disclosed
// under the Mutual Non-Disclosure Agreement.
//
// Notice
// ALL NVIDIA DESIGN SPECIFICATIONS AND CODE ("MATERIALS") ARE PROVIDED "AS IS"
// NVIDIA MAKES NO REPRESENTATIONS, WARRANTIES, EXPRESSED, IMPLIED, STATUTORY,
// OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ANY
// IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// NVIDIA Corporation assumes no responsibility for the consequences of use of
// such information or for any infringement of patents or other rights of third
// parties that may result from its use. No license is granted by implication or
// otherwise under any patent or patent rights of NVIDIA Corporation. No third
// party distribution is allowed unless expressly authorized by NVIDIA.  Details
// are subject to change without notice. This code supersedes and replaces all
// information previously supplied. NVIDIA Corporation products are not
// authorized for use as critical components in life support devices or systems
// without express written approval of NVIDIA Corporation.
//
// Copyright (c) 2016-2024 NVIDIA Corporation. All rights reserved.
//
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and any
// modifications thereto. Any use, reproduction, disclosure or distribution of
// this software and related documentation without an express license agreement
// from NVIDIA Corporation is strictly prohibited.
//
////////////////////////////////////////////////////////////////////////////////
#ifndef DWROADCAST_DW_ROADCAST_BASE_TYPES_ROADCASTBASETYPES_H_
#define DWROADCAST_DW_ROADCAST_BASE_TYPES_ROADCASTBASETYPES_H_
// Generated by dwProto from roadcast_base_types.proto DO NOT EDIT BY HAND!
// See //3rdparty/shared/dwproto/README.md for more information

#include <dw/core/base/Types.h>

#include <dw/calibration/engine/common/CalibrationTypesExtra.h>
#include <dw/egomotion/base/EgomotionExtra.h>
#include <dw/egomotion/base/EgomotionTypes.h>
#include <dw/egomotion/global/GlobalEgomotionTypes.h>
#include <dw/rig/Rig.h>

#ifdef __cplusplus
extern "C" {
#endif

#define DW_ROADCAST_MAX_MESSAGE_SIZE 5242880U
/// Max length allow for the name and frameid field describing dwTransformation3f
#define DW_TRANSFORMATION3F_STR_MAX_LEN 16
/// Max length allowed for the timeseries name field
#define DW_TIMESERIES_NAME_MAX_LEN 64
/// Max length allowed for the timeseriesarray name field
#define DW_TIMESERIESARRAY_NAME_MAX_LEN 64
/// Max length allowed for count of timeseriesarray values
#define DW_TIMESERIESARRAY_MAX_TIMESERIES_CNT 100
/// Max length allow for the identifier describing dwEgomotionResult, dwEgomotionPose and dwGlobalEgomotionResult
#define DW_EGOMOTIONRESULT_IDENTIFIER_MAX_LEN 16

/// @brief Type of reference point for object
typedef enum dwObjectReferencePoint {
    DW_OBJECT_REFERENCE_UNDEFINED    = 0,
    DW_OBJECT_REFERENCE_FRONTLEFT    = 1,
    DW_OBJECT_REFERENCE_FRONTCENTER  = 2,
    DW_OBJECT_REFERENCE_FRONTRIGHT   = 3,
    DW_OBJECT_REFERENCE_RIGHTCENTER  = 4,
    DW_OBJECT_REFERENCE_REARRIGHT    = 5,
    DW_OBJECT_REFERENCE_REARCENTER   = 6,
    DW_OBJECT_REFERENCE_REARLEFT     = 7,
    DW_OBJECT_REFERENCE_LEFTCENTER   = 8,
    DW_OBJECT_REFERENCE_OBJECTCENTER = 9,
} dwObjectReferencePoint;

/// @brief Object status
typedef enum dwObjectStatus {
    DW_OBJECT_STATUS_PREDICTED               = 0,
    DW_OBJECT_STATUS_TRACKED                 = 1,
    DW_OBJECT_STATUS_DETECTED                = 2,
    DW_OBJECT_STATUS_TRACKED_AND_PREDICTED   = 3,
    DW_OBJECT_STATUS_CLOSE_CUT_IN_OR_PASSING = 4,
} dwObjectStatus;

/// @brief Type of object for view
typedef enum dwObjectView {
    DW_OBJECT_VIEW_FRONT_LEFT        = 0,
    DW_OBJECT_VIEW_FRONT             = 1,
    DW_OBJECT_VIEW_FRONT_RIGHT       = 2,
    DW_OBJECT_VIEW_REAR_LEFT         = 3,
    DW_OBJECT_VIEW_REAR              = 4,
    DW_OBJECT_VIEW_REAR_RIGHT        = 5,
    DW_OBJECT_VIEW_CROSS_LEFT        = 6,
    DW_OBJECT_VIEW_CROSS_RIGHT       = 7,
    DW_OBJECT_VIEW_INTERIOR_STEERING = 8,
    DW_OBJECT_VIEW_INTERIOR_FRONT    = 9,
    DW_OBJECT_VIEW_INTERIOR          = 10,
} dwObjectView;

// This amounts to max(ObjectView) + 1, i.e. the required size of
// an array if these enum values are interpreted as array offsets.
#define DW_OBJECT_VIEW_COUNT 11

/// @brief Type of object for motion
typedef enum dwObjectMotion {
    DW_OBJECT_MOTION_UNKNOWN    = 0,
    DW_OBJECT_MOTION_MOVING     = 1,
    DW_OBJECT_MOTION_STATIONARY = 2,
    DW_OBJECT_MOTION_STOPPED    = 3,
} dwObjectMotion;

/// @brief Type of relationship object
typedef enum dwObjectRelationship {
    DW_OBJECT_RELATION_NONE = 0,
    DW_OBJECT_RELATION_CIPV = 1, //!< Closest In Path Vehicle
    DW_OBJECT_RELATION_CIPS = 2, //!< Closest In Path Stationary OBject
} dwObjectRelationship;

/// @brief type of state of AV process
typedef enum dwProcState {
    DW_PROC_START    = 0,
    DW_PROC_PROGRESS = 1,
    DW_PROC_END      = 2,
} dwProcState;

/// @brief type of incident UI survey request
typedef enum dwSurveyRequestType {
    DW_SURVEY_REQUEST_TYPE_DRIVER_INCIDENT_SURVEY             = 0,
    DW_SURVEY_REQUEST_TYPE_LOGIN_SURVEY                       = 1,
    DW_SURVEY_REQUEST_TYPE_DISENGAGEMENT_SURVEY_SUBMITTED     = 2,
    DW_SURVEY_REQUEST_TYPE_DISENGAGEMENT_SURVEY_STATE_REQUEST = 3,
    DW_SURVEY_REQUEST_TYPE_DISENGAGEMENT_NO_SURVEY_REQUIRED   = 4,
} dwSurveyRequestType;

/// @brief type of heart-beat signal message
typedef enum dwHeartbeatSource {
    DW_HEARTBEAT_SOURCE_DRIVEIX                 = 0,
    DW_HEARTBEAT_SOURCE_DRIVEAV                 = 1,
    DW_HEARTBEAT_SOURCE_DRIVEAR                 = 2,
    DW_HEARTBEAT_SOURCE_DRIVEUI_INCIDENT_SURVEY = 3,
    DW_HEARTBEAT_SOURCE_TELEMETRY               = 4,
} dwHeartbeatSource;

/// @brief Type of surround monitor
typedef enum dwCastSurroundMonitorType {
    DW_CAST_SURROUND_MONITOR_NOTHING           = 0,
    DW_CAST_SURROUND_MONITOR_ALL               = 1,
    DW_CAST_SURROUND_MONITOR_INDIVIDUAL_STATES = 2,
    DW_CAST_SURROUND_MONITOR_FUSION_STATE      = 3,
} dwCastSurroundMonitorType;

/// @brief container for measurement
typedef struct dwMeasurement
{
    bool isValid;
    float32_t value;
    float32_t stdDev;
} dwMeasurement;

//// @brief container for 3D vector of measurement
typedef struct dwVectorMeasurement
{
    dwMeasurement x;
    dwMeasurement y;
    dwMeasurement z;
} dwVectorMeasurement;

/// @brief container for 4D vector of measurement
typedef struct dwVector4Measurement
{
    dwMeasurement x;
    dwMeasurement y;
    dwMeasurement z;
    dwMeasurement w;
} dwVector4Measurement;

/// @brief Sensor fusion info.
/// Original information from sensors before the sensor fusion step.
typedef struct dwSensorFusionInfo
{
    bool isAssociated;    //!< whether this sensor information was used during sensor fusion step or not if it's false all other members of this struct are not valid
    uint32_t id;          //!< object id before sensor fusion
    float32_t distance;   //!< distance before sensor fusion, in rig coordinate for now.
    float32_t azimuth;    //!< azimuth before sensor fusion, in rig coordinate for now.
    float32_t inverseTTC; //!< inverseTTC before sensor fusion, in front camera's coordinate for now.
} dwSensorFusionInfo;

typedef struct dwTransformation
{
    char8_t name[DW_TRANSFORMATION3F_STR_MAX_LEN];
    char8_t frameid[DW_TRANSFORMATION3F_STR_MAX_LEN];
    dwVector4Measurement col1;
    dwVector4Measurement col2;
    dwVector4Measurement col3;
    dwVector4Measurement col4;
    dwTime_t timestampA;
    dwTime_t timestampB;
    dwEgomotionTransformationQuality uncertainty;
} dwTransformation;

/// @brief structure to hold dwTransformation3f and associated name and frameid
/// If applicable, timestamp A and B indicate time interval for transformation(A->B).
typedef struct dwTransformation3fPayload
{
    dwTransformation3f transformation;
    dwEgomotionTransformationQuality uncertainty;
    char8_t name[DW_TRANSFORMATION3F_STR_MAX_LEN];
    char8_t frameid[DW_TRANSFORMATION3F_STR_MAX_LEN];
    dwTime_t timestampA;
    dwTime_t timestampB;
} dwTransformation3fPayload;

/// @brief structure to hold dwEgomotionResult and associated identifier
typedef struct dwEgomotionResultPayload
{
    dwEgomotionResult egomotionResult;
    dwEgomotionUncertainty egomotionUncertainty;
    char8_t identifier[DW_EGOMOTIONRESULT_IDENTIFIER_MAX_LEN];
} dwEgomotionResultPayload;

/// @brief structure to hold dwGlobalEgomotion and associated identifier
typedef struct dwGlobalEgomotionResultPayload
{
    dwGlobalEgomotionResult globalEgomotionResult;
    dwGlobalEgomotionUncertainty globalEgomotionUncertainty;
    char8_t identifier[DW_EGOMOTIONRESULT_IDENTIFIER_MAX_LEN];
} dwGlobalEgomotionResultPayload;

/// @brief structure to hold Egomotion Pose and associated identifier
typedef struct dwEgomotionPosePayload
{
    dwEgomotionPose pose;
    char8_t identifier[DW_EGOMOTIONRESULT_IDENTIFIER_MAX_LEN];
} dwEgomotionPosePayload;

/// @brief structure to contain statistics of AV events
typedef struct dwAVStats
{
    uint64_t statsCounter;         //<! to keep count of this message
    dwProcState state;             //<! state of process
    uint64_t timestamp;            //<! timestamp in uS
    uint64_t timeElapsed;          //!< elapsed running time (using wall clock)
    uint64_t simulatedTimeElapsed; //!< elapsed simulation time (last sensor event time â€“ first sensor event time)
    uint64_t cameraEvents;         //!< number of camera events
    uint64_t radarEvents;          //!< number of radar events
    uint64_t lidarEvents;          //!< number of LIDAR events
    uint64_t GPSEvents;            //!< number of GPS events
    uint64_t IMUEvents;            //!< number of IMU events
    uint64_t CANEvents;            //!< number of CAN events
    float64_t fps;                 //!< Roadrunner camera FPS
    uint64_t frameCount;           //!< Roadrunner frame count
} dwAVStats;

/// @brief structure to contain survey request
typedef struct dwSurveyRequest
{
    uint32_t lat_control_id; //!< latitude control (lane keeping) engage
    uint32_t lon_control_id; //!< longitudinal (ACC) engage
    dwSurveyRequestType surveyRequestType;
} dwSurveyRequest;

/// @brief structure to contain heart-beat signal message
typedef struct dwHeartbeat
{
    dwHeartbeatSource source;
} dwHeartbeat;

/// @brief Time series
typedef struct dwTimeSeries
{
    char8_t signalName[DW_TIMESERIES_NAME_MAX_LEN]; //!< Name for the timeseries signal
    float32_t timeSeries;                           //!< value of the signal
} dwTimeSeries;

/// @brief Time series Array
typedef struct dwTimeSeriesArray
{
    char8_t signalName[DW_TIMESERIESARRAY_NAME_MAX_LEN]; //!< Name for the timeseries signal
    float32_t timeSeriesArray[DW_TIMESERIESARRAY_MAX_TIMESERIES_CNT];
    uint32_t timeCount; //!< Stores the occupied/valid length of timeSeriesArray
} dwTimeSeriesArray;

typedef struct dwRoadCastCalibratedIMUIntrinsics
{
    dwCalibratedIMUIntrinsics intrinsics;
    char8_t sensorName[DW_MAX_RIG_SENSOR_NAME_SIZE];
} dwRoadCastCalibratedIMUIntrinsics;

#ifdef __cplusplus
}
#endif

#endif // DWROADCAST_DW_ROADCAST_BASE_TYPES_ROADCASTBASETYPES_H_
