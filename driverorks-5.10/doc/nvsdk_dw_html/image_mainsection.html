<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!--
 * Copyright (c) 2009-2014 NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA Corporation and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA Corporation is strictly prohibited.
-->
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<title>DriveWorks SDK Reference: Image</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="Nvidia.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="reverb-search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="nv.css" rel="stylesheet" type="text/css" />
<link href="nvdwx.css" rel="stylesheet" type="text/css"/>
<style>
 body {
 background-position: 350px 150px;
 background-image: url(watermark.png);
 background-repeat: no-repeat;
 background-attachment: fixed;
 }
 </style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table width="99%" border="0" cellspacing="1" cellpadding="1">
  <tbody>
    <tr valign="middle">
      <td rowspan="2" height="44" width="19%">
        <div>
            <a id="nv-logo" href="https://www.nvidia.com/"></a>
        </div>
      <td width="81%" height="44">
        <div style="text-align:right; font-weight: bold; font-size:20px"> <br/>DriveWorks SDK Reference </div>
        <div style="text-align:right">
        5.10.87 Release <br/> For Test and Development only <br/> <br/> </div>
    </td>
  </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('image_mainsection.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Image </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#image_about">About This Module</a></li>
<li class="level1"><a href="#image_intro">Image</a></li>
<li class="level1"><a href="#image_storage">Storage in Memory</a></li>
<li class="level1"><a href="#image_formats">ImageFormats</a></li>
<li class="level1"><a href="#image_format_conversion">Image Format Conversion</a></li>
<li class="level1"><a href="#image_streamer">Image Streamer</a></li>
<li class="level1"><a href="#image_frame_capture">Frame Capture</a></li>
<li class="level1"><a href="#image_use_cases">Relevant Tutorials</a></li>
<li class="level1"><a href="#image_apis">APIs</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="image_about"></a>
About This Module</h1>
<p >The image module is composed of 3 submodules</p>
<h1><a class="anchor" id="image_intro"></a>
Image</h1>
<p >The image module contains structures and methods that allow the user to create and set images handles that are compatible with NVIDIA<sup>&reg;</sup> DriveWorks modules. An image is represented generically as a handle <code><a class="el" href="group__image__group.html#ga0941eecdd67c03c4685bb895f0066f59">dwImageHandle_t</a></code>, which can be passed to a DriveWorks module for processing, or more specifically as a C struct. The struct differs in content based on the type of image and the properties. All images share common properties:</p>
<h3>Image Properties</h3>
<p >The image properties are:</p><ul>
<li>the type (see next section)</li>
<li>the size in pixel (width and height):</li>
<li>the format represented as an enum DW_IMAGE_FORMAT_COLORSPACE_PIXELTYPE(_PIXELORDER) where the COLORSPACE (RGB, YUV, RAW etc...) describes the appearance of the individual pixel, the PIXELTYPE (UINT8, FLOAT16 etc...) describes the trivial datatype of each pixel and the PIXELORDER (PLANAR, SEMIPLANAR) which describes how the specific color space is arranged in memory. The PIXELORDER can be INTERLEAVED (name is omitted) in which case the individual channels of the COLORSPACE are contiguous, PLANAR in which the channels are separated in different planes or SEMIPLANAR in which some channels are contiguous, some not (see YUV420)</li>
<li>the meta which is the collection of metadata information and pointers to datalines. This field is filled by the dwSensorCamera and contains parsed datalines (in the form of sensor specific info) and uint8_t pointers pointing to the memory location of the raw datalines. This is supported not supported in GL images and it will appear only when dealing with RAW images</li>
<li>the memoryLayout can be: <code><a class="el" href="group__image__group.html#gga6bc1e1a5e55d1d8fa58e0708c57f973eac3cb16a256bbdb28a50a52bfbfc634d1" title="the default memory layout for a given image type, can be either pitch or block">DW_IMAGE_MEMORY_TYPE_DEFAULT</a></code>, <code><a class="el" href="group__image__group.html#gga6bc1e1a5e55d1d8fa58e0708c57f973ea7de476aa5d96fa5ecf1e7b21a4268e3a" title="pitch linear memory layout">DW_IMAGE_MEMORY_TYPE_PITCH</a></code>, <code><a class="el" href="group__image__group.html#gga6bc1e1a5e55d1d8fa58e0708c57f973eada82c898959571553fb8529d6c8e8fd1" title="block memory layout">DW_IMAGE_MEMORY_TYPE_BLOCK</a></code> and represents the arrangement of data in memory. Only CUDA and NVMEDIA can handle both types, CPU is stricktly pitch and GL is stricktly block, The default memory layout will automatically choose the proper layout (once given to a DW module) In the <code><a class="el" href="group__image__group.html#structdwImageMetaData" title="Additional meta information stored with each image.">dwImageMetaData</a></code> we can find extra information about the image, including sensor statistics and important flags. Among these info there is also <code>dwImageAllocationAttrListHandle_t</code> which is filled by APIs from other modules in the form dwX_appendAllocationAttributes() (see <code>dwSensorCamera_appendAllocationAttributes</code> for example). These attributes are external and are required by HW units in order to interface with the created image. The call can be done on the same <a class="el" href="group__image__group.html#structdwImageProperties" title="Defines the properties of the image.">dwImageProperties</a> for all the modules that will require to use the image that is being created. Special care must be taken when using <a class="el" href="group__image__group.html#structdwImageProperties" title="Defines the properties of the image.">dwImageProperties</a> in case it has this set, which can have multiple attributes from multiple modules leading to incorrect allocation if not intended.</li>
</ul>
<h3>Image Types</h3>
<p >Any image can be created by calling <code><a class="el" href="group__image__group.html#ga8e16c1f43bb5f86cd4dc024d97fd3c5c" title="Creates and allocates resources for a dwImageHandle_t based on the properties passed as input.">dwImage_create()</a></code> and should be followed by a <code><a class="el" href="group__image__group.html#gaddeb433370ecb3793507aacebd3dfa9c" title="Destroys the image handle and frees any memory created by dwImage_create().">dwImage_destroy()</a></code> when the image is not needed anymore. The creation is specific to the type of image and there are 4 supported types. After the image is created it is possible to pass the handle to DriveWorks modules, if they accept the opaque handle, otherwise it's possible to retrieve a struct specific to the image type. The struct allows direct access to the content of the image and any modification will affect original image.</p>
<h4>CPU Images</h4>
<p >A CPU image is stored as a pitch memory buffer represented by an array of pointers, an array of pitches and properties. Its content can be retrieved from a dwImageHandle_t by calling <a class="el" href="group__image__group.html#gaf4135c14f431a8f188f192d5e89f3dcf" title="Retrieves the dwImageCPU of a dwImageHandle_t.">dwImage_getCPU()</a> and it will return a <a class="el" href="group__image__group.html#structdwImageCPU" title="Defines a CPU-based image.">dwImageCPU</a> and it contains:</p><ul>
<li><a class="el" href="group__image__group.html#structdwImageProperties" title="Defines the properties of the image.">dwImageProperties</a> prop: image properties</li>
<li>size_t pitch[] : the pitches, one per image plane</li>
<li>uint8_t *data[]: the pointers to the actual data, one pointer per image plane</li>
<li><code><a class="el" href="group__core__basictypes__group.html#gac4840df46df4be80c7f427057740af65" title="Specifies a timestamp unit, in microseconds.">dwTime_t</a></code> timestamp_us : the timestamp of acquisition from a sensor. If the image is created by the user, it is 0</li>
</ul>
<p >The CPU image is created by specifying <a class="el" href="group__image__group.html#gga6623e81a22d553d705467c56ba429c34a6dec04f88bdc0a28b1eed0c933abfc0f">DW_IMAGE_CPU</a> type in the properties and calling</p><ul>
<li><a class="el" href="group__image__group.html#ga8e16c1f43bb5f86cd4dc024d97fd3c5c" title="Creates and allocates resources for a dwImageHandle_t based on the properties passed as input.">dwImage_create()</a>: will create the handle and also allocate memory for data[] based on the properties. Destroying such image will also free the memory</li>
<li><a class="el" href="group__image__group.html#ga68747924ad510feddac52bd5c938a59b" title="Creates a dwImageHandle_t based on the properties passed and binds a memory buffer provided by the ap...">dwImage_createAndBindBuffer()</a>: will create the handle but not allocate memory, instead data[] will point to the buffers allocated and passed by the user. The function trusts that the user buffers match the properties specified. Destroying such image will only destroy the handle, the ownership of the buffer remains on the user</li>
</ul>
<h4>CUDA Images</h4>
<p >A CUDA Image can have 2 forms, a Pitch pointer or CUDA Array form. The two forms are allocated and occupy different domains on GPU memory, one being a Pitch linear pointer, the other being a Block memory cuda Array (thought of as a Texture). It is possible to retrieve the content by calling <a class="el" href="group__image__group.html#ga9b63aaeb03d9cbda4fec269ec09f53e6" title="Retrieves the dwImageCUDA of a dwImageHandle_t.">dwImage_getCUDA()</a> and receiving a <a class="el" href="group__image__group.html#structdwImageCUDA" title="Defines a CUDA image.">dwImageCUDA</a> struct, containing:</p><ul>
<li><a class="el" href="group__image__group.html#structdwImageProperties" title="Defines the properties of the image.">dwImageProperties</a> prop: image properties</li>
<li>size_t pitch[] : the pitches, one per image plane. The pitches are used to access content only for pitch linear pointers</li>
<li>void *dptr[]: the pointers to the actual pitch linear data on GPU device, one per image plane. Valid if prop.memoryLayout is <a class="el" href="group__image__group.html#gga6bc1e1a5e55d1d8fa58e0708c57f973ea7de476aa5d96fa5ecf1e7b21a4268e3a" title="pitch linear memory layout">DW_IMAGE_MEMORY_TYPE_PITCH</a> (or DEFAULT)</li>
<li>cudaArray_t array[]: the block memory cuda arrays, one per image plane. Valid if prop.memoryLayout is <a class="el" href="group__image__group.html#gga6bc1e1a5e55d1d8fa58e0708c57f973eada82c898959571553fb8529d6c8e8fd1" title="block memory layout">DW_IMAGE_MEMORY_TYPE_BLOCK</a>. Note that only image formats with planes composed of 1/2/4 channels are valid in block memory</li>
<li><code><a class="el" href="group__core__basictypes__group.html#gac4840df46df4be80c7f427057740af65" title="Specifies a timestamp unit, in microseconds.">dwTime_t</a></code> timestamp_us : the timestamp of acquisition from a sensor. If the image is created by the user, it is 0</li>
</ul>
<p >The CUDA image is created by specifying DW_IMAGE_CUDA type in the properties and calling</p><ul>
<li><a class="el" href="group__image__group.html#ga8e16c1f43bb5f86cd4dc024d97fd3c5c" title="Creates and allocates resources for a dwImageHandle_t based on the properties passed as input.">dwImage_create()</a>: will create the handle and also allocate memory for dptr[] for pitch layouts and for arrays[] for block layouts, based on properties. Destroying such image will also free the device memory</li>
<li><a class="el" href="group__image__group.html#ga68747924ad510feddac52bd5c938a59b" title="Creates a dwImageHandle_t based on the properties passed and binds a memory buffer provided by the ap...">dwImage_createAndBindBuffer()</a>: will create the handle but not allocate memory, instead dptr[] will point to the buffers allocated using cuda functions (ie cudaMallocPitch()) and passed by the user. The function trusts that the user buffers match the properties specified. Destroying such image will only destroy the handle, the ownership of the buffer remains on the user</li>
<li><a class="el" href="group__image__group.html#ga5366a8915391ee31f969eb31e308ddff" title="Creates a dwImageHandle_t based on the properties passed and binds a cudaArray_t to it.">dwImage_createAndBindCUDAArray()</a>: will create the handle but not allocate cudaArrays, instead array[] will point to the cudaArray allocated by the user calling cudaMallocArray(). The behavior is analogous to the function above</li>
</ul>
<p >Note: CUDA image created with format listed in (see NvMedia Images section below) are streamable from CUDA to NvMedia. </p><h4>GL Images</h4>
<p >A GL image is stored as a GLuint texture present on the GPU. An invalid texture has texID of 0 but it has a positive value when properly created. It is possible to retrieve the ocntent by calling <a class="el" href="group__gl__image__group.html#gaecfa0a8969c06f1fb1990eacb15e34b5" title="Retrieves the dwImageGL of a dwImageHandle_t.">dwImage_getGL()</a> and will receive a <a class="el" href="group__gl__image__group.html#structdwImageGL" title="Defines a GL texture image.">dwImageGL</a> and it contains:</p><ul>
<li><a class="el" href="group__image__group.html#structdwImageProperties" title="Defines the properties of the image.">dwImageProperties</a> prop: image properties</li>
<li>GLuint tex: the index of the texture on the GPU</li>
<li>GLenum target: the GL texture target. In almost all use cases it is a GL_TEXTURE_2D</li>
<li><code><a class="el" href="group__core__basictypes__group.html#gac4840df46df4be80c7f427057740af65" title="Specifies a timestamp unit, in microseconds.">dwTime_t</a></code> timestamp_us : the timestamp of acquisition from a sensor. If the image is created by the user, it is 0</li>
</ul>
<p >The GL image is created by specifying DW_IMAGE_GL type in the properties and calling</p><ul>
<li><a class="el" href="group__image__group.html#ga8e16c1f43bb5f86cd4dc024d97fd3c5c" title="Creates and allocates resources for a dwImageHandle_t based on the properties passed as input.">dwImage_create()</a>: will create the handle and also generate a GL texture, based on properties and target. Destroying such image will also destroys the GL texture</li>
<li>dwImage_createAndBindGLTexture(): will create the handle and use the GL texture created by the user. The function trusts that the user buffers match the properties specified. Destroying such image will only destroy the handle, the ownership of the texture remains on the user</li>
</ul>
<h4>NvMedia Images</h4>
<p >An NvMedia image is stored as a pointer to the low level NvMedia API image struct. For specific information on NvMedia images, see the following information in <em>NVIDIA DRIVE 5.1 PDK</em>:</p><ul>
<li>"Image Processing and Management" in "Understanding NvMedia".</li>
<li>"NvMedia API for Tegra" in the API Reference. (Click the API tab to access the API Reference.)</li>
</ul>
<p >It is possible to access the pointer by calling <a class="el" href="group__image__group.html#ga8cf01ef08e3bf8fb40d3c7831bdbd4f6" title="Retrieves the dwImageNvMedia of a dwImageHandle_t.">dwImage_getNvMedia()</a> and receive a <a class="el" href="group__image__group.html#structdwImageNvMedia" title="Defines an NvMedia image.">dwImageNvMedia</a> that contains:</p><ul>
<li><a class="el" href="group__image__group.html#structdwImageProperties" title="Defines the properties of the image.">dwImageProperties</a> prop: image properties</li>
<li>NvMediaImage *img: pointer to the low level NvMedia image</li>
<li><code><a class="el" href="group__core__basictypes__group.html#gac4840df46df4be80c7f427057740af65" title="Specifies a timestamp unit, in microseconds.">dwTime_t</a></code> timestamp_us : the timestamp of acquisition from a sensor. If the image is created by the user, it is 0</li>
</ul>
<p >The NvMedia image is created by specifying <a class="el" href="group__image__group.html#gga6623e81a22d553d705467c56ba429c34af198f98d9a7403bb0b4187f8f0d9ec66">DW_IMAGE_NVMEDIA</a> type in the properties and calling <code><a class="el" href="group__image__group.html#ga8e16c1f43bb5f86cd4dc024d97fd3c5c" title="Creates and allocates resources for a dwImageHandle_t based on the properties passed as input.">dwImage_create()</a></code>. This will create the handle and also create a NvMediaImage using low level NvMedia API calls, based on properties. Destroying such image will also destroys the NvMediaImage using the low level NvMedia API. Here is a list of supported formats:</p><ul>
<li>DW_IMAGE_FORMAT_R_UINT8</li>
<li>DW_IMAGE_FORMAT_RGBA_UINT8</li>
<li>DW_IMAGE_FORMAT_VUYX_UINT8</li>
<li>DW_IMAGE_FORMAT_VUYX_UINT16</li>
<li>DW_IMAGE_FORMAT_RGB_UINT8_PLANAR</li>
<li>DW_IMAGE_FORMAT_YUV420_UINT8_PLANAR</li>
<li>DW_IMAGE_FORMAT_YUV420_UINT8_SEMIPLANAR</li>
<li>DW_IMAGE_FORMAT_YUV420_UINT16_SEMIPLANAR</li>
<li>DW_IMAGE_FORMAT_YUV422_UINT8_SEMIPLANAR</li>
<li>DW_IMAGE_FORMAT_YUV_UINT8_PLANAR</li>
<li>DW_IMAGE_FORMAT_YUV_UINT16_PLANAR</li>
</ul>
<p >Calling dwImage_createAndBindNvMedia() will create the handle and use NvMediaImage created by the user. The function trusts that the user NvMediaImage matches the properties specified. Destroying such image will only destroy the handle, the ownership of the NvMediaImage remains on the user. Note that images created with this API are not streamable to CUDA</p>
<h1><a class="anchor" id="image_storage"></a>
Storage in Memory</h1>
<p >Images can be stored in memory in various formats. One dimension of this variation is interleaved vs planar storage for multi-channel images. For example, an interleaved RGB image has 1 plane with 3 channels. A YUV420 planar image has 3 planes, with 1 channel each.</p>
<p >Memory layout can be either pitch or block, depending on the type. CPU images are always pitch, GL images are always block, whereas CUDA and NvMedia images can be either.</p>
<h1><a class="anchor" id="image_formats"></a>
ImageFormats</h1>
<p >The image format describes data type, color space and arrangement of the pixels</p>
<h3>Interleaved formats</h3>
<ul>
<li>DW_IMAGE_FORMAT_R: single channel grayScale</li>
<li>DW_IMAGE_FORMAT_RG: two-channels single plane (RGRGRGRG...) representing Red Green (or X Y coordinates)</li>
<li>DW_IMAGE_FORMAT_RGB: 3-channels single planae (RGBRGBRGBRGB)</li>
<li>DW_IMAGE_FORMAT_RGBA: 4-channels single plane (RGBARGBARGBA), Red Green Blue Alpha. Alpha channel used for color blending</li>
<li>DW_IMAGE_FORMAT_RGBX: 4-channels single plane (RGBXRGBXRGBX), Red Green Blue X-empty, for HW acceleration</li>
<li>DW_IMAGE_FORMAT_VUYX: 4-channles single plane (VUYXVUYXVUYX), V U Y-luminace X-empty, representing YUV444</li>
</ul>
<h3>Planar formats</h3>
<ul>
<li>DW_IMAGE_FORMAT_RGB_DATATYPE_PLANAR: 3 planes, 1 channel each, Red Green Blue</li>
<li>DW_IMAGE_FORMAT_RCB_DATATYPE_PLANAR: 3 planes, 1 channel each, Red Clear Blue, Clear represents unfiltered color channel, non tonemapped</li>
<li>DW_IMAGE_FORMAT_RCC_DATATYPE_PLANAR: 3 planes, 1 channel each, Red Clear Clear, Clear represents unfiltered color channel, non tonemapped</li>
<li>DW_IMAGE_FORMAT_YUV420_DATATYPE_PLANAR: 3 planes, 1 channel each, Y-luminance U V, representing YUV420 with U and V at half resolution</li>
<li>DW_IMAGE_FORMAT_YUV_DATATYPE_PLANAR: 3 planes, 1 channel each, Y-luminance U V, representing YUV444</li>
</ul>
<h3>other formats</h3>
<ul>
<li>DW_IMAGE_FORMAT_YUV420_DATATYPE_SEMIPLANAR: 2 planes, 1 channel + 2 channels (YYYYYYY... UVUVUVUVUV), representing YUV420 with U and V at half resolution</li>
</ul>
<h3>RAW</h3>
<ul>
<li>DW_IMAGE_FORMAT_RAW_UINT16: RAW color array from images arriving from the sensor. The color array is describet in dwCameraRawFormat</li>
<li>DW_IMAGE_FORMAT_RAW_FLOAT16: result of debayering of RAW_UINT16</li>
</ul>
<h1><a class="anchor" id="image_format_conversion"></a>
Image Format Conversion</h1>
<p >Images can be converted into a different format, while retaining the same type. The user must allocate the output image and the conversion will be based on the properties of the input and output images. Only CUDA and NvMedia images support this operation. The converter will not change the size of the image. If all properties are identical, the converter will perform an identical copy.</p>
<h3>Table for supported format conversions</h3>
<p >The following table showcases the formats allowed in conversion. This list is for CUDA images in pitch memory. A subset of those images are also convertible in NvMedia image, indicated with *</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">From   </th><th class="markdownTableHeadNone">To    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">any format and layout   </td><td class="markdownTableBodyNone">same format and layout (simple copy)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">any format, layout <code><a class="el" href="group__image__group.html#gga6bc1e1a5e55d1d8fa58e0708c57f973ea7de476aa5d96fa5ecf1e7b21a4268e3a" title="pitch linear memory layout">DW_IMAGE_MEMORY_TYPE_PITCH</a></code>   </td><td class="markdownTableBodyNone">same format, layout <code><a class="el" href="group__image__group.html#gga6bc1e1a5e55d1d8fa58e0708c57f973eada82c898959571553fb8529d6c8e8fd1" title="block memory layout">DW_IMAGE_MEMORY_TYPE_BLOCK</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">any format, layout <code><a class="el" href="group__image__group.html#gga6bc1e1a5e55d1d8fa58e0708c57f973eada82c898959571553fb8529d6c8e8fd1" title="block memory layout">DW_IMAGE_MEMORY_TYPE_BLOCK</a></code>   </td><td class="markdownTableBodyNone">same format, layout <code><a class="el" href="group__image__group.html#gga6bc1e1a5e55d1d8fa58e0708c57f973ea7de476aa5d96fa5ecf1e7b21a4268e3a" title="pitch linear memory layout">DW_IMAGE_MEMORY_TYPE_PITCH</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cafd0a74d985844cd8f48f130a13768fa7" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca3bd3c4e72a8ef0652237783a22d1fd29">DW_IMAGE_FORMAT_RGBA_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cafd0a74d985844cd8f48f130a13768fa7" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caf8471d5957b4b6a2efb1204bf18358c1" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_FLOAT16_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cafd0a74d985844cd8f48f130a13768fa7" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cab2fb06a827487d4c163e478b9f8a1c25" title="YUV encoding formats from camera.">DW_IMAGE_FORMAT_YUV420_UINT8_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca41ec0dffc09915f347f80755ff5c9e66" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca3bd3c4e72a8ef0652237783a22d1fd29">DW_IMAGE_FORMAT_RGBA_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caf8471d5957b4b6a2efb1204bf18358c1" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_FLOAT16_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca3bd3c4e72a8ef0652237783a22d1fd29">DW_IMAGE_FORMAT_RGBA_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca41ec0dffc09915f347f80755ff5c9e66" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cab5aecf27b19ea783f383f38f4f931f9f" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_FLOAT16</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca41ec0dffc09915f347f80755ff5c9e66" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca41ec0dffc09915f347f80755ff5c9e66" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca41ec0dffc09915f347f80755ff5c9e66" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cab2fb06a827487d4c163e478b9f8a1c25" title="YUV encoding formats from camera.">DW_IMAGE_FORMAT_YUV420_UINT8_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca3bd3c4e72a8ef0652237783a22d1fd29">DW_IMAGE_FORMAT_RGBA_UINT8</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cafd0a74d985844cd8f48f130a13768fa7" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca3bd3c4e72a8ef0652237783a22d1fd29">DW_IMAGE_FORMAT_RGBA_UINT8</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cab2fb06a827487d4c163e478b9f8a1c25" title="YUV encoding formats from camera.">DW_IMAGE_FORMAT_YUV420_UINT8_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca3bd3c4e72a8ef0652237783a22d1fd29">DW_IMAGE_FORMAT_RGBA_UINT8</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca8435cf35d1209b90d1af428e1ce3d69a">DW_IMAGE_FORMAT_YUV420_UINT8_SEMIPLANAR</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca3bd3c4e72a8ef0652237783a22d1fd29">DW_IMAGE_FORMAT_RGBA_UINT8</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caa69986b6d6a521c2b94db22f3900030c">DW_IMAGE_FORMAT_R_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca3bd3c4e72a8ef0652237783a22d1fd29">DW_IMAGE_FORMAT_RGBA_UINT8</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca41ec0dffc09915f347f80755ff5c9e66" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca3bd3c4e72a8ef0652237783a22d1fd29">DW_IMAGE_FORMAT_RGBA_UINT8</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caf8471d5957b4b6a2efb1204bf18358c1" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_FLOAT16_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca17653d8ebcfdd0bfeb96d3e7c0aaa3cb">DW_IMAGE_FORMAT_RGBA_FLOAT16</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caf8471d5957b4b6a2efb1204bf18358c1" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_FLOAT16_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca8435cf35d1209b90d1af428e1ce3d69a">DW_IMAGE_FORMAT_YUV420_UINT8_SEMIPLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cafd0a74d985844cd8f48f130a13768fa7" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca8435cf35d1209b90d1af428e1ce3d69a">DW_IMAGE_FORMAT_YUV420_UINT8_SEMIPLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cab2fb06a827487d4c163e478b9f8a1c25" title="YUV encoding formats from camera.">DW_IMAGE_FORMAT_YUV420_UINT8_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca8435cf35d1209b90d1af428e1ce3d69a">DW_IMAGE_FORMAT_YUV420_UINT8_SEMIPLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caa69986b6d6a521c2b94db22f3900030c">DW_IMAGE_FORMAT_R_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca8435cf35d1209b90d1af428e1ce3d69a">DW_IMAGE_FORMAT_YUV420_UINT8_SEMIPLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca3bd3c4e72a8ef0652237783a22d1fd29">DW_IMAGE_FORMAT_RGBA_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caba693e7d14f8f10181ad6a490971db08">DW_IMAGE_FORMAT_YUV420_UINT16_SEMIPLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca3bd3c4e72a8ef0652237783a22d1fd29">DW_IMAGE_FORMAT_RGBA_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca8435cf35d1209b90d1af428e1ce3d69a">DW_IMAGE_FORMAT_YUV420_UINT8_SEMIPLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca41ec0dffc09915f347f80755ff5c9e66" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca8435cf35d1209b90d1af428e1ce3d69a">DW_IMAGE_FORMAT_YUV420_UINT8_SEMIPLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caf8471d5957b4b6a2efb1204bf18358c1" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_FLOAT16_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caba693e7d14f8f10181ad6a490971db08">DW_IMAGE_FORMAT_YUV420_UINT16_SEMIPLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caf8471d5957b4b6a2efb1204bf18358c1" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_FLOAT16_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cab2fb06a827487d4c163e478b9f8a1c25" title="YUV encoding formats from camera.">DW_IMAGE_FORMAT_YUV420_UINT8_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca3bd3c4e72a8ef0652237783a22d1fd29">DW_IMAGE_FORMAT_RGBA_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cab2fb06a827487d4c163e478b9f8a1c25" title="YUV encoding formats from camera.">DW_IMAGE_FORMAT_YUV420_UINT8_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cafd0a74d985844cd8f48f130a13768fa7" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cab2fb06a827487d4c163e478b9f8a1c25" title="YUV encoding formats from camera.">DW_IMAGE_FORMAT_YUV420_UINT8_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca8435cf35d1209b90d1af428e1ce3d69a">DW_IMAGE_FORMAT_YUV420_UINT8_SEMIPLANAR</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cab2fb06a827487d4c163e478b9f8a1c25" title="YUV encoding formats from camera.">DW_IMAGE_FORMAT_YUV420_UINT8_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caa69986b6d6a521c2b94db22f3900030c">DW_IMAGE_FORMAT_R_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cab2fb06a827487d4c163e478b9f8a1c25" title="YUV encoding formats from camera.">DW_IMAGE_FORMAT_YUV420_UINT8_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca41ec0dffc09915f347f80755ff5c9e66" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087cab2fb06a827487d4c163e478b9f8a1c25" title="YUV encoding formats from camera.">DW_IMAGE_FORMAT_YUV420_UINT8_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caf8471d5957b4b6a2efb1204bf18358c1" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_FLOAT16_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caa74c5d2a75829c273d0b71f0da3ec4e8">DW_IMAGE_FORMAT_VUYX_UINT8</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca3bd3c4e72a8ef0652237783a22d1fd29">DW_IMAGE_FORMAT_RGBA_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caa74c5d2a75829c273d0b71f0da3ec4e8">DW_IMAGE_FORMAT_VUYX_UINT8</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca41ec0dffc09915f347f80755ff5c9e66" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caa74c5d2a75829c273d0b71f0da3ec4e8">DW_IMAGE_FORMAT_VUYX_UINT8</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca7ce6ff7ca14b92b3ec51fd5da5e92270">DW_IMAGE_FORMAT_YUV_UINT8_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca5f884b94e3a38a4ed14bee0610dd490e">DW_IMAGE_FORMAT_VUYX_UINT16</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca17653d8ebcfdd0bfeb96d3e7c0aaa3cb">DW_IMAGE_FORMAT_RGBA_FLOAT16</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca5f884b94e3a38a4ed14bee0610dd490e">DW_IMAGE_FORMAT_VUYX_UINT16</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caf8471d5957b4b6a2efb1204bf18358c1" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_FLOAT16_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca5f884b94e3a38a4ed14bee0610dd490e">DW_IMAGE_FORMAT_VUYX_UINT16</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca8b0a953dbf0b2beb1bbe8cb4bdd52ba3">DW_IMAGE_FORMAT_YUV_UINT16_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca7ce6ff7ca14b92b3ec51fd5da5e92270">DW_IMAGE_FORMAT_YUV_UINT8_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca3bd3c4e72a8ef0652237783a22d1fd29">DW_IMAGE_FORMAT_RGBA_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca7ce6ff7ca14b92b3ec51fd5da5e92270">DW_IMAGE_FORMAT_YUV_UINT8_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca41ec0dffc09915f347f80755ff5c9e66" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_UINT8_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">*<code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca7ce6ff7ca14b92b3ec51fd5da5e92270">DW_IMAGE_FORMAT_YUV_UINT8_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caa74c5d2a75829c273d0b71f0da3ec4e8">DW_IMAGE_FORMAT_VUYX_UINT8</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca8b0a953dbf0b2beb1bbe8cb4bdd52ba3">DW_IMAGE_FORMAT_YUV_UINT16_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca17653d8ebcfdd0bfeb96d3e7c0aaa3cb">DW_IMAGE_FORMAT_RGBA_FLOAT16</a></code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca8b0a953dbf0b2beb1bbe8cb4bdd52ba3">DW_IMAGE_FORMAT_YUV_UINT16_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087caf8471d5957b4b6a2efb1204bf18358c1" title="Not backed by NvSci.">DW_IMAGE_FORMAT_RGB_FLOAT16_PLANAR</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca8b0a953dbf0b2beb1bbe8cb4bdd52ba3">DW_IMAGE_FORMAT_YUV_UINT16_PLANAR</a></code>   </td><td class="markdownTableBodyNone"><code><a class="el" href="group__image__group.html#ggab7343d2f61d8450ef8451d4ec73d087ca5f884b94e3a38a4ed14bee0610dd490e">DW_IMAGE_FORMAT_VUYX_UINT16</a></code>   </td></tr>
</table>
<h1><a class="anchor" id="image_streamer"></a>
Image Streamer</h1>
<p >An image streamer streams an image from a type X to a type Y, preserving the rest of the properties. All streamers (see note B) need to be initialized in order to allocate the necessary resources for the streaming (for example an image pool), depending on the type of streamer. On low level, all streamers differ in behavior and performance, so the choice and number of streamers should be planned wisely (Note D). The idea of streaming is based on the logic of producer and consumer.</p><ol type="1">
<li>the producer sends an image through the stream. It is possible to send images in a sequence up to the maximum size of the streamer's internal pool (4). At this point the producer waits for the consumer</li>
<li>the consumer receives the converted image and consumes it</li>
<li>the consumer returns the image to the producer</li>
<li>the producer returns the image, freeing the taken location in the pool. The producer will wait for the consumer based on a timeout</li>
</ol>
<p >Driveworks 5.0 is changing image streamers backend from Egl based image streamers to Nvsci based image streamers. This is applicable for cross process as well as intra-process image streamers.</p>
<p ><b>Intra process image streamer</b> handles everything internally and applications using Driveworks image streamer APIs would not require any code changes. DW 5.0 image streamers use NvSciBuf internally and hence involves no copy when streaming to another API. Note: To use images with intra process streamers, they should be created with <a class="el" href="group__image__group.html#ga8e16c1f43bb5f86cd4dc024d97fd3c5c" title="Creates and allocates resources for a dwImageHandle_t based on the properties passed as input.">dwImage_create()</a> API. Binding extrenally allocated buffers using <a class="el" href="group__image__group.html#ga68747924ad510feddac52bd5c938a59b" title="Creates a dwImageHandle_t based on the properties passed and binds a memory buffer provided by the ap...">dwImage_createAndBindBuffer()</a> are not NvSciBuf based and hence are non streamable. For bind image case, cross process streamer can be leveraged for streaming.</p>
<p ><b>Cross process image streamers</b> are based on NvStreams API and involves copy from application's image to an image allocation maintained internally by NvSci pool. The allocations of this pool are available in producer and consumer process. Since this is copy based, images created using both <a class="el" href="group__image__group.html#ga8e16c1f43bb5f86cd4dc024d97fd3c5c" title="Creates and allocates resources for a dwImageHandle_t based on the properties passed as input.">dwImage_create()</a> as well as <a class="el" href="group__image__group.html#ga68747924ad510feddac52bd5c938a59b" title="Creates a dwImageHandle_t based on the properties passed and binds a memory buffer provided by the ap...">dwImage_createAndBindBuffer()</a> are supported.</p>
<p ><em>Note: The copy is done only in producer side using hardware engines available.</em></p>
<p >Cross process image streamers in DW 5.0 abstracts the functionality internally to setup NvSciStream for streaming images from producer to consumer. As shown in below table, comma separated Key-Value pairs can be specified in parameters string as preferred by application. Of these, only the steam name is mandatory while others are optional.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Key   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">streamName   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">corresponds to endpoint name as specified in nvsciipc.cfg on Linux or DTB on QNX    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">streamNames   </td><td class="markdownTableBodyNone">csv strings   </td><td class="markdownTableBodyNone">Use for multicast on producer side. See example below    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">fifo-size   </td><td class="markdownTableBodyNone">numeric   </td><td class="markdownTableBodyNone">Optional parameter. Can be used to specify fifo size to be used by streamer. By default this value isinternally set to 4    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">timeoutUsec   </td><td class="markdownTableBodyNone">numeric   </td><td class="markdownTableBodyNone">timeout value in micro seconds passed to NvSciStream for timeout. Producer and consumer should use large enough value in to account for latency of one created after the other   </td></tr>
</table>
<p >Examples of parameter string:</p>
<ul>
<li>Example 1: Just endpoints (stream) names<ul>
<li>on producer side parameters = "streamName=nvscistream_0"</li>
<li>on consumer side parameters = "streamName=nvscistream_1"</li>
</ul>
</li>
<li>Example 2: Stream names and fifo size<ul>
<li>on producer side "streamName=nvscistream_0,fifo-size=4
    * on consumer side  "streamName=nvscistream_1,fifo-size=4</li>
</ul>
</li>
<li>Example 3: Multicast params<ul>
<li>on producer side multicastng to 4 consumers, use parameters = "streamNames=[nvscistream_0,nvscistream_2,nvscistream_4,nvscistream_6]"</li>
<li>The 4 consumers corresponding to endpoint names used in producer, use<ul>
<li>parameters = "streamName=nvscistream_1" for consumer corresponding to nvscistream_0</li>
<li>parameters = "streamName=nvscistream_3" for consumer corresponding to nvscistream_2</li>
<li>parameters = "streamName=nvscistream_5" for consumer corresponding to nvscistream_4</li>
<li>parameters = "streamName=nvscistream_7" for consumer corresponding to nvscistream_6</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Supported Image Streamer Inputs and Outputs</h3>
<p >The following table describes the possible streaming combinations, given by image type (<a class="el" href="group__image__group.html#ga6623e81a22d553d705467c56ba429c34">dwImageType</a>).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">From (column) \ To (row)   </th><th class="markdownTableHeadCenter">CPU   </th><th class="markdownTableHeadCenter">GL   </th><th class="markdownTableHeadCenter">CUDA   </th><th class="markdownTableHeadCenter">NvMedia    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CPU   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">X*   </td><td class="markdownTableBodyCenter">X*   </td><td class="markdownTableBodyCenter">X    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GL   </td><td class="markdownTableBodyCenter">X*   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">X   </td><td class="markdownTableBodyCenter">X    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CUDA   </td><td class="markdownTableBodyCenter">X   </td><td class="markdownTableBodyCenter">X*   </td><td class="markdownTableBodyCenter">X (only cross-process)   </td><td class="markdownTableBodyCenter">X    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">NvMedia   </td><td class="markdownTableBodyCenter">X   </td><td class="markdownTableBodyCenter">X   </td><td class="markdownTableBodyCenter">X   </td><td class="markdownTableBodyCenter">X (only cross-process)   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>* Supported on iGPU only.</dd></dl>
<h3>Streamable Image Formats and Types</h3>
<p >CUDA-&gt;CPU and vice versa support all formats.</p>
<p >NvMedia -&gt; CUDA and viceversa support:</p><ul>
<li>DW_IMAGE_FORMAT_R_UINT8</li>
<li>DW_IMAGE_FORMAT_RGBA_UINT8</li>
<li>DW_IMAGE_FORMAT_VUYX_UINT8</li>
<li>DW_IMAGE_FORMAT_VUYX_UINT16</li>
<li>DW_IMAGE_FORMAT_RGB_UINT8_PLANAR</li>
<li>DW_IMAGE_FORMAT_YUV420_UINT8_PLANAR</li>
<li>DW_IMAGE_FORMAT_YUV420_UINT8_SEMIPLANAR</li>
<li>DW_IMAGE_FORMAT_YUV420_UINT16_SEMIPLANAR</li>
<li>DW_IMAGE_FORMAT_YUV422_UINT8_SEMIPLANAR</li>
<li>DW_IMAGE_FORMAT_YUV_UINT8_PLANAR</li>
<li>DW_IMAGE_FORMAT_YUV_UINT16_PLANAR</li>
<li>DW_IMAGE_FORMAT_RAW_UINT16</li>
</ul>
<p >CPU/NvMedia/CUDA -&gt; GL and viceversa support only DW_IMAGE_FORMAT_RGBA_UINT8</p>
<p >Note A: The streamable images are based on NvSci and are required to be in sysmem.</p>
<p >Note B: The streamer CUDA-&gt;GL on DGPU due to technical limitations, allocates extra resources from the one needed and perform extra operations during the stream, leading to performance penalties. Cross process streamers also keep a pool of internal resources that are shared across process and are copied to from image streamed by application. In process streamers incur zero copy when images are streamed from one API to another within process.</p>
<p >Note C: Some formats are stored by NvMedia in a different order compared to the format name. Specifically YUV420/422 planar, the UV planes are actually ordered as VU. The order is restored to the one of the format name when streamed to either CPU or CUDA</p>
<h3>Underlying streaming mechanism for each combination</h3>
<p >The following table describes the mechanism for each streaming combination. 'X' indicates the combination is not available.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">From (column) \ To (row)   </th><th class="markdownTableHeadCenter">CPU   </th><th class="markdownTableHeadCenter">CUDA Pitch   </th><th class="markdownTableHeadCenter">CUDA Block   </th><th class="markdownTableHeadCenter">GL   </th><th class="markdownTableHeadCenter">NvMedia    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CPU   </td><td class="markdownTableBodyCenter">X   </td><td class="markdownTableBodyCenter">cudaMemcpy2DAsync   </td><td class="markdownTableBodyCenter">cudaMemcpy2DToArrayAsync   </td><td class="markdownTableBodyCenter">glBufferData - GL_STATIC_DRAW   </td><td class="markdownTableBodyCenter">NvSci mapping    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CUDA Pitch   </td><td class="markdownTableBodyCenter">cudaMemcpy2DAsync   </td><td class="markdownTableBodyCenter">X   </td><td class="markdownTableBodyCenter">X   </td><td class="markdownTableBodyCenter">cudaMemcpy3DAsync (iGPU, X86) - GL-&gt;CPU-&gt;CUDA (dGPU)   </td><td class="markdownTableBodyCenter">NvSci mapping    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CUDA Block   </td><td class="markdownTableBodyCenter">cudaMemcpy2DFromArrayAsync   </td><td class="markdownTableBodyCenter">X   </td><td class="markdownTableBodyCenter">X   </td><td class="markdownTableBodyCenter">cudaMemcpy3DAsync (iGPU, X86) - GL-&gt;CPU-&gt;CUDA (dGPU)   </td><td class="markdownTableBodyCenter">NvSci mapping    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GL   </td><td class="markdownTableBodyCenter">glReadPixels   </td><td class="markdownTableBodyCenter">cudaMemcpy3DAsync (iGPU, X86) - X (dGPU)   </td><td class="markdownTableBodyCenter">cudaMemcpy3DAsync (iGPU, X86) - X (dGPU)   </td><td class="markdownTableBodyCenter">X   </td><td class="markdownTableBodyCenter">EGL    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">NvMedia   </td><td class="markdownTableBodyCenter">direct map (only for pitch linear)   </td><td class="markdownTableBodyCenter">NvSci mapping   </td><td class="markdownTableBodyCenter">NvSci mapping   </td><td class="markdownTableBodyCenter">EGL   </td><td class="markdownTableBodyCenter">X   </td></tr>
</table>
<p >Note: EGL is not avilable in safety build and will be discontinued in Drive OS 6.0</p>
<p >The NvSci streaming mechanism, within the same process, has minimal overhead. Note also that when creating images, the pointers will reside on the GPU current to the time of creation, therefore accessing and streaming must be done ensuring the same GPU is current (see <code>dwContext_getCurrentGPU</code>)</p>
<h3>Expected performance on NVIDIA DRIVE AGX Developer Kit</h3>
<p >The following table gives the streaming performance on NVIDIA DRIVE AGX Developer Kit. Values are given in microseconds and represent the average of 1000 runs; std and spike values are in parenthesis.</p>
<p >'D' indicates dGPU performance and 'I' iGPU. If 'D' or 'I' is not specified, then the performance is independent of the GPU.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadCenter">RGBA 8bit   </th><th class="markdownTableHeadCenter">RAW 16bit   </th><th class="markdownTableHeadCenter">YUV 420 SP 8bit    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CPU-&gt;CUDA   </td><td class="markdownTableBodyCenter">20 D (4.2, 117) <br  />
 402 I (38.8, 643)   </td><td class="markdownTableBodyCenter">20 D (5.1, 160) <br  />
 364 I (38.0, 804)   </td><td class="markdownTableBodyCenter">34 D (8.6, 404) <br  />
 426 I (38.3, 654)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CPU-&gt;GL   </td><td class="markdownTableBodyCenter">11 (7.9, 263)   </td><td class="markdownTableBodyCenter">NA   </td><td class="markdownTableBodyCenter">NA    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CPU-&gt;NvMedia   </td><td class="markdownTableBodyCenter">19 (3.5, 56)   </td><td class="markdownTableBodyCenter">690 (4.1, 711)   </td><td class="markdownTableBodyCenter">NA    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CUDA-&gt;CPU   </td><td class="markdownTableBodyCenter">24 D (6.4, 139) <br  />
 407 I (29.2. 616)   </td><td class="markdownTableBodyCenter">23 D (4.6, 147) <br  />
 422 I (35.6, 798)   </td><td class="markdownTableBodyCenter">41 D (7.1, 168) <br  />
 449 I (56.1, 632)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CUDA-&gt;GL   </td><td class="markdownTableBodyCenter">175 (73.9, 1436)   </td><td class="markdownTableBodyCenter">NA   </td><td class="markdownTableBodyCenter">NA    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CUDA-&gt;NvMedia   </td><td class="markdownTableBodyCenter">NA   </td><td class="markdownTableBodyCenter">NA   </td><td class="markdownTableBodyCenter">NA    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">NvMedia-&gt;CPU   </td><td class="markdownTableBodyCenter">7 (3.9, 71)   </td><td class="markdownTableBodyCenter">8 (3.1, 35)   </td><td class="markdownTableBodyCenter">14 (5.3, 138)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">NvMedia-&gt;CUDA   </td><td class="markdownTableBodyCenter">52 D (11.6, 2161) <br  />
 34 I (7.5, 908)   </td><td class="markdownTableBodyCenter">49 D (9.4, 2020) <br  />
 37 I (11.8, 724)   </td><td class="markdownTableBodyCenter">71 D (12.6, 3786) <br  />
 36 I (16.5, 923)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">NvMedia-&gt;GL   </td><td class="markdownTableBodyCenter">38 (13.2, 282)   </td><td class="markdownTableBodyCenter">NA   </td><td class="markdownTableBodyCenter">NA    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GL-&gt;CPU   </td><td class="markdownTableBodyCenter">75 (25.1, 784)   </td><td class="markdownTableBodyCenter">NA   </td><td class="markdownTableBodyCenter">NA    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GL-&gt;CUDA   </td><td class="markdownTableBodyCenter">1950 (146.4, 2411)   </td><td class="markdownTableBodyCenter">NA   </td><td class="markdownTableBodyCenter">NA    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">GL-&gt;NvMedia   </td><td class="markdownTableBodyCenter">136 (180.9, 1635)   </td><td class="markdownTableBodyCenter">NA   </td><td class="markdownTableBodyCenter">NA   </td></tr>
</table>
<p >Note 1: GL-based times were taken on iGPU</p>
<p >Note 2: Some streamers, especially EGL-based, have spikes for the first few frames, due to hidden optimizations that are performed during the first few iterations. Similar spikes may also occur for CUDA images.</p>
<h1><a class="anchor" id="image_frame_capture"></a>
Frame Capture</h1>
<p >A frame capture has 2 purposes:</p><ul>
<li>capture the content of an onscreen Window into a <a class="el" href="group__gl__image__group.html#structdwImageGL" title="Defines a GL texture image.">dwImageGL</a></li>
<li>serialize a rogue <a class="el" href="group__gl__image__group.html#structdwImageGL" title="Defines a GL texture image.">dwImageGL</a> or <a class="el" href="group__image__group.html#structdwImageCUDA" title="Defines a CUDA image.">dwImageCUDA</a> into a h264/h265 stream without needing to use a sensor camera This module is ideal for recording a video of a DW based application being rendered on screen</li>
</ul>
<h1><a class="anchor" id="image_use_cases"></a>
Relevant Tutorials</h1>
<ul>
<li><a class="el" href="image_usecase5.html">Image Creation and Conversion</a></li>
<li><a class="el" href="md_src_dw_image_doc_public_usecase6.html#image_usecase6">image_usecase6</a></li>
<li><a class="el" href="image_usecase2.html">Image Streamer</a></li>
<li><a class="el" href="image_usecase4.html">Image Streamer Multi-Thread</a></li>
<li><a class="el" href="image_usecase3.html">Image Streamer Cross-Process</a></li>
<li><a class="el" href="image_usecase1.html">Image Capture</a></li>
</ul>
<h1><a class="anchor" id="image_apis"></a>
APIs</h1>
<ul>
<li><a class="el" href="group__image__group.html">Image Interface</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->

  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">
        Advance Information | Subject to Change |
        Prepared and Provided under NDA | Generated by NVIDIA |
        PR-08397-V5.0
      </li>
     </ul>
  </div>
</body>
</html>
