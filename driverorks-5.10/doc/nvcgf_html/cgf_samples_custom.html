<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!--
 * Copyright (c) 2022 NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA Corporation and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA Corporation is strictly prohibited.
-->
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Compute Graph Framework SDK Reference: Custom Node and Integration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="Nvidia.ico" type="image/x-icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="nv.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 110px;">
  <td id="projectlogo" width="19%">
    <a id="nv-logo" href="https://www.nvidia.com/"></a>
  </td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Compute Graph Framework SDK Reference
   &#160;<span id="projectnumber">5.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('cgf_samples_custom.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Custom Node and Integration </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#develop-a-cpp-node">Develop a C++ node using DriveWorks Core &amp; framework APIs</a><ul><li class="level2"><a href="#creating-a-public-node-interface">Creating a public node interface</a><ul><li class="level3"><a href="#pass-definition-and-pass-descriptors">Pass Definition and Pass Descriptors</a><ul><li class="level4"><a href="#pass-definition">Pass Definition</a></li>
<li class="level4"><a href="#pass-descriptors">Pass Descriptors</a></li>
</ul>
</li>
<li class="level3"><a href="#port-definition-and-port-descriptors">Port Definition and Port Descriptors</a><ul><li class="level4"><a href="#port-definition">Port Definition</a></li>
<li class="level4"><a href="#port-descriptors">Port Descriptors</a></li>
<li class="level4"><a href="#parameter-descriptors">Parameter Descriptors</a></li>
</ul>
</li>
<li class="level3"><a href="#constructor">Constructor</a></li>
</ul>
</li>
<li class="level2"><a href="#creating-a-node-implementation">Creating a node implementation</a><ul><li class="level3"><a href="#init-passes">Init Passes</a></li>
<li class="level3"><a href="#init-ports">Init Ports</a></li>
<li class="level3"><a href="#pass-implementation-sample">Pass Implementation</a><ul><li class="level4"><a href="#postprocessing-pass-implementation">PostProcessing Pass Implementation</a></li>
</ul>
</li>
<li class="level3"><a href="#logging">Logging</a></li>
<li class="level3"><a href="#validation-function">Validation</a></li>
<li class="level3"><a href="#reset">Reset</a></li>
</ul>
</li>
<li class="level2"><a href="#register-custom-node">Register custom node</a></li>
</ul>
</li>
<li class="level1"><a href="#json-description">JSON description</a><ul><li class="level2"><a href="#node-json">Node JSON</a></li>
<li class="level2"><a href="#graphlet-json">Graphlet JSON</a></li>
<li class="level2"><a href="#application-json">Application JSON</a><ul><li class="level3"><a href="#schedule-configuration">Schedule Configuration</a></li>
</ul>
</li>
<li class="level2"><a href="#sensorlayout-json">SensorLayout JSON</a></li>
</ul>
</li>
<li class="level1"><a href="#steps-to-create-a-compute-graph-framework-application">Steps to create a compute graph framework application</a></li>
<li class="level1"><a href="#integrate-a-custom-node-json-into-the-application">Integrate a custom node JSON into the application</a></li>
<li class="level1"><a href="#verify-the-functionality-of-custom-node">Verify the functionality of custom node</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="develop-a-cpp-node"></a>
Develop a C++ node using DriveWorks Core &amp; framework APIs</h1>
<p >To create C++ code implementation of a node, the user can use the node.json to C++ code template Python script to first create a template based on the node JSON file. In this section, we will discuss the C++ code structure in more detail. There are two types of nodes and, when creating one, you will inherit from one of these two interfaces:</p>
<ul>
<li><b>ProcessNode</b></li>
<li><b>SensorNode</b></li>
</ul>
<p >In this document, we will focus mainly on process nodes. Process node covers anything that performs data processing. For instance, ISPNode would be a process node. When creating a node that is not based on a DriveWorks module, the developer is free to inherit from the abstract classes ProcessNode or SensorNode, but care must be taken to ensure that the node catches its own exceptions as there will be no guarantee of that. It is highly recommended to inherit from the Simple classes and ExceptionSafe classes.</p>
<h2><a class="anchor" id="creating-a-public-node-interface"></a>
Creating a public node interface</h2>
<p >For each node, there will be a public node interface and an implementation file. When creating a public node interface file, the interface should inherit from <code>ExceptionSafeProcessNode</code> for a process node type. This is an exception catching layer so that the exceptions thrown in the implementation get translated into status codes. Upon construction, ExceptionSafeProcessNode requires a pointer to the implementation. Thus, when creating the <code>HelloWorldNode</code> node, in the constructor call to the parent class ExceptionSafeProcessNode a pointer to <code>HelloWorldNodeImpl</code> would be passed. An example can be found in public header of the object detector custom node, <code>HelloWorldNode.hpp</code>.</p>
<h3><a class="anchor" id="pass-definition-and-pass-descriptors"></a>
Pass Definition and Pass Descriptors</h3>
<h4><a class="anchor" id="pass-definition"></a>
Pass Definition</h4>
<p >When defining the public header for the node, each pass is defined with macro <code><a class="el" href="SimpleNodeT_8hpp.html#a32ffc5c3aacb60d67453333eb86bb254" title="Register a pass function with the node base class.">NODE_REGISTER_PASS()</a></code>. <code><a class="el" href="SimpleNodeT_8hpp.html#a32ffc5c3aacb60d67453333eb86bb254" title="Register a pass function with the node base class.">NODE_REGISTER_PASS()</a></code> macro definition is defined in file <code>&lt;<a class="el" href="SimpleNodeT_8hpp.html">dwcgf/node/SimpleNodeT.hpp</a>&gt;</code>. In <code>HelloWorldNodeImpl.cpp</code>, each pass is defined in initPass method: </p><pre class="fragment">// post-process CPU pass
NODE_REGISTER_PASS(
    "PROCESS"_sv,
    [this]() { return process(); });
</pre> <h4><a class="anchor" id="pass-descriptors"></a>
Pass Descriptors</h4>
<p >We can also describe each pass using pass descriptor APIs to make pass visualization in DW Graph GUI Tool. Pass descriptor API’s are defined in file <code>&lt;<a class="el" href="PassDescriptor_8hpp.html">dwcgf/pass/PassDescriptor.hpp</a>&gt;</code> </p><pre class="fragment">static constexpr auto passes()
{
    return describePassCollection(
        describePass("SETUP"_sv, DW_PROCESSOR_TYPE_CPU),
        describePass("PREPROCESS"_sv, DW_PROCESSOR_TYPE_GPU),
        describePass("INFERENCE"_sv, DW_PROCESSOR_TYPE_GPU),
        describePass("POSTPROCESS"_sv, DW_PROCESSOR_TYPE_CPU),
        describePass("TEARDOWN"_sv, DW_PROCESSOR_TYPE_CPU));
};
</pre> <h3><a class="anchor" id="port-definition-and-port-descriptors"></a>
Port Definition and Port Descriptors</h3>
<h4><a class="anchor" id="port-definition"></a>
Port Definition</h4>
<p >In addition to defining passes, each input and output must be defined with a name. In addition, ports can also be defined with portIndex function which is defined in <code>&lt;<a class="el" href="PortDescriptor_8hpp.html">dwcgf/port/PortDescriptor.hpp</a>&gt;</code>. Port init can be done with MACROs defined in <a class="el" href="SimpleNodeT_8hpp.html">SimpleNodeT.hpp</a>. An input port definition example in SumNode is listed below: </p><pre class="fragment">// Setup input ports.
NODE_INIT_INPUT_PORT("VALUE_0"_sv);
</pre><p> Similar with Pass Descriptor, we can also describe each port using port descriptor APIs to make port visualization in DW Graph GUI Tool. Pass descriptor API’s are defined in file <code>&lt;dwcgf/pass/PortDescriptor.hpp&gt;</code>.</p>
<h4><a class="anchor" id="port-descriptors"></a>
Port Descriptors</h4>
<pre class="fragment">static constexpr auto describeInputPorts()
{
    using namespace dw::framework;
    return describePortCollection();
};
static constexpr auto describeOutputPorts()
{
    using namespace dw::framework;
    return describePortCollection(
        DW_DESCRIBE_PORT(int, "VALUE_0"_sv, PortBinding::REQUIRED),
        DW_DESCRIBE_PORT(int, "VALUE_1"_sv, PortBinding::REQUIRED));
};
</pre> <h4><a class="anchor" id="parameter-descriptors"></a>
Parameter Descriptors</h4>
<p >The last describe function needed is the describeParameters API. It is used to describe the parameters of the node. Below is an example code from HelloWorldNode code. The function describes the parameter "name" which is also specified in HelloWorldNode.node.json: </p><pre class="fragment">static constexpr auto describeParameters()
{
    return describeConstructorArguments&lt;HelloWorldNodeParams, dwContextHandle_t&gt;(
        describeConstructorArgument(
            DW_DESCRIBE_PARAMETER(
                std::string,
                "name"_sv,
                &amp;HelloWorldNodeParams::name)),
        describeConstructorArgument(
            DW_DESCRIBE_UNNAMED_PARAMETER(
                dwContextHandle_t)));
}
</pre> <h3><a class="anchor" id="constructor"></a>
Constructor</h3>
<p >There should be a constructor inside the public header that instantiates the node. Commonly a struct which is named <code>&lt;node_name&gt;Params</code> is passed as a parameter and contains the desired parameters to configure the node. A constructor parameter of type <code>dwContextHandle_t</code> is commonly passed separately. Here is an example: </p><pre class="fragment">HelloWorldNodeImpl(const HelloWorldNodeParams&amp; params, const dwContextHandle_t ctx);
</pre><p> Besides the constructor, a node needs a static create function and registers the node using a macro in the cpp file. A simplest example is to utilize something like below: </p><pre class="fragment">dw::framework::create&lt;Node&gt;(ParameterProvider&amp; provider);
</pre> <h2><a class="anchor" id="creating-a-node-implementation"></a>
Creating a node implementation</h2>
<p >When creating an implementation file, the file should inherit from the concrete class SimpleProcessNode for a process node type. Using a similar pattern as stated earlier, the name of the node implementation should be the name of the node plus "Impl" (e.g., "HelloWorldNodeImpl"). In the implementation file, you should store all of the unique_ptr’s to the input and output ports.</p>
<h3><a class="anchor" id="init-passes"></a>
Init Passes</h3>
<pre class="fragment">void ISPNodeImpl::initPasses()
{
    // SETUP and TEARDOWN passes are using default impl
    NODE_REGISTER_PASS("PROCESS"_sv, [this]() { return process(); });
}
</pre> <h3><a class="anchor" id="init-ports"></a>
Init Ports</h3>
<pre class="fragment">void ISPNodeImpl::initPorts()
{
    // Setup input ports, waitTime is zero by default
    NODE_INIT_INPUT_PORT("IMAGE"_sv);

    // Setup output ports
    const auto&amp; transParams = m_params.transParams;
    dwImageProperties imageProps{};
    imageProps.width        = transParams.inputRes.x;
    imageProps.height       = transParams.inputRes.y;
    imageProps.type         = DW_IMAGE_CUDA;
    imageProps.memoryLayout = DW_IMAGE_MEMORY_TYPE_PITCH;
    imageProps.format       = DW_IMAGE_FORMAT_RGB_FLOAT16_PLANAR;

    // Create RGB (fp16) full resolution image
    FRWK_CHECK_DW_ERROR(dwImage_create(&amp;m_convertedFullImage, imageProps, m_ctx));

    imageProps.width  = transParams.outputRes.x;
    imageProps.height = transParams.outputRes.y;
    NODE_INIT_OUTPUT_PORT("IMAGE"_sv, imageProps);
    NODE_INIT_OUTPUT_PORT("IMAGE_FOVEAL"_sv, imageProps);
    bool refSignal{};
    NODE_INIT_OUTPUT_PORT("FOVEAL_SIGNAL"_sv, refSignal);
}
</pre> <h3><a class="anchor" id="pass-implementation-sample"></a>
Pass Implementation</h3>
<p >Pass is the real meat behind the execution abstraction model because it provides the scheduler with timing information about each task and guarantees by defining each task is atomic with respect to the processor type it runs on. This theoretically allows a scheduler to efficiently schedule parallel work. When creating a pass, the heart of it is the function that is passed into NODE_REGISTER_PASS macro. The function will be passed a pointer to the node impl itself as the only parameter and should return a status. The user doesn’t need to explicitly write setup and teardown pass functions. These functions are implemented in the background. The setup pass gets executed first every time the node is executed, and the teardown gets called at the end of execution. The teardown is where all the outputs are sent. This is done by calling the member port output send method. Below is an example of the function passed into NODE_REGISTER_PASS macro in the HelloWorldNode:</p>
<h4><a class="anchor" id="postprocessing-pass-implementation"></a>
PostProcessing Pass Implementation</h4>
<pre class="fragment">dwStatus HelloWorldNodeImpl::process()
{
    auto&amp; outPort0 = NODE_GET_OUTPUT_PORT("VALUE_0"_sv);
    auto&amp; outPort1 = NODE_GET_OUTPUT_PORT("VALUE_1"_sv);
    if (outPort0.isBufferAvailable() &amp;&amp; outPort1.isBufferAvailable())
    {
        *outPort0.getBuffer() = m_port0Value++;
        DW_LOGD &lt;&lt; "[Epoch " &lt;&lt; m_epochCount &lt;&lt; "] Sent value0 = " &lt;&lt; *outPort0.getBuffer() &lt;&lt; Logger::State::endl;
        outPort0.send();

        *outPort1.getBuffer() = m_port1Value--;
        DW_LOGD &lt;&lt; "[Epoch " &lt;&lt; m_epochCount &lt;&lt; "] Sent value1 = " &lt;&lt; *outPort1.getBuffer() &lt;&lt; Logger::State::endl;
        outPort1.send();
    }
    DW_LOGD &lt;&lt; "[Epoch " &lt;&lt; m_epochCount++ &lt;&lt; "] Greetings from HelloWorldNodeImpl: Hello " &lt;&lt; m_params.name.c_str() &lt;&lt; "!" &lt;&lt; Logger::State::endl;
    return DW_SUCCESS;
}
</pre> <h3><a class="anchor" id="logging"></a>
Logging</h3>
<p >A static LOG_TAG should also be provided to identify the node. This is a label used for logging inside the framework. It should be the same as the node name. For example, <code>HelloWorldNode</code> would be: </p><pre class="fragment">static constexpr char LOG_TAG[] = "HelloWorldNode";
</pre><p> Any messages logged out within the node (e.g. a message of an exception) will be prepended by the LOG_TAG, therefore the message to be logged would suffice if it contains information in the following pattern: <code>&lt;function name&gt;:&lt;message&gt;</code>. As a example, for an exception to be thrown, we can have the following message, </p><pre class="fragment">throw Exception(DW_NOT_IMPLEMENTED, "validate: not implemented");
</pre> <h3><a class="anchor" id="validation-function"></a>
Validation</h3>
<p >The validate function by default is implemented in <a class="el" href="SimpleNodeT_8hpp.html">SimpleNodeT.hpp</a>. The user can overwrite this function for any custom validate implementation. An example to use validate() would be to validate all the ports are bound to the appropriate channels (any required ports, that is). For example, a camera node may have processed output and raw output ports, but only one is required to be hooked up. A validate method can inspect the ports to make sure at least one is bound. In the ISPNode, we validate if the required inputPortImageHandle is available: </p><pre class="fragment">dwStatus ISPNodeImpl::validate()
{
    dwStatus status = Base::validate();
    // Check foveal ports are bound when foveal enabled
    if (status == DW_SUCCESS &amp;&amp;
        (fovealEnabled() &amp;&amp; (!NODE_GET_OUTPUT_PORT("IMAGE_FOVEAL"_sv).isBound() || !NODE_GET_OUTPUT_PORT("FOVEAL_SIGNAL"_sv).isBound())))
    {
        return DW_NOT_READY;
    }

    return status;
}
</pre> <h3><a class="anchor" id="reset"></a>
Reset</h3>
<p >The reset function by default is implemented in <a class="el" href="SimpleNodeT_8hpp.html">SimpleNodeT.hpp</a>. However, user can overwrite the reset function for any custom reset implementation. </p><pre class="fragment">dwStatus HelloWorldNodeImpl::reset()
{
    m_port0Value = 0;
    m_port1Value = 10000;
    return Base::reset();
}
</pre> <h2><a class="anchor" id="register-custom-node"></a>
Register custom node</h2>
<pre class="fragment">#include &lt;dwcgf/node/NodeFactory.hpp&gt;
DW_REGISTER_NODE(dw::framework::HelloWorldNode)
</pre> <h1><a class="anchor" id="json-description"></a>
JSON description</h1>
<h2><a class="anchor" id="node-json"></a>
Node JSON</h2>
<ul>
<li><b>library</b>: The basename of the shared library containing the node. Omitting this key indicates that the node has no implementation. The value ‘static’ indicates that the node is part of a statically linked library rather than a dynamically loaded shared library</li>
<li><b>name</b>: The fully qualified C++ type name of the node class</li>
<li><b>inputPorts</b>: The input ports. The order is user defined and matches the order in the C++ code if applicable</li>
<li><b>outputPorts</b>: The output ports. The order is user defined and matches the order in the C++ code if applicable</li>
<li><b>parameters</b>: The parameters. The order is user defined and matches the order in the C++ code if applicable</li>
<li><b>passes</b>: The passes. The order is user defined and matches the order in the C++ code if applicable. In the default case where all passes are sequential, this means the passes must follow topological order</li>
</ul>
<h2><a class="anchor" id="graphlet-json"></a>
Graphlet JSON</h2>
<ul>
<li><b>name</b>: The unique name of the graphlet</li>
<li><b>inputPorts</b>: The input ports. The order is user defined</li>
<li><b>outputPorts</b>: The output ports. The order is user defined</li>
<li><b>parameters</b>: The parameters. The order is user defined</li>
<li><b>subcomponents</b>: The subcomponents. The order should be alphabetical</li>
<li><b>connections</b>: The connections. The order should be alphabetical based on the source and the connection parameter names<ul>
<li><b>type</b>: specifies the channel type connected to the port. Currently supports NvSciStream, socket or localshmem. Default value is localshmem</li>
<li><b>singleton</b>: true/false, suggest a single buffer at producer side. A read&amp;write lock is enforced on that piece of buffer so that there’s no conflict reading while writing or the other way around. Singleton flag is NOT supposed to be used with mailbox</li>
<li><b>mailbox</b>: true/false, this is to identify the mail box channels in the graph. This is useful for STM schedule table generation. Channel identified with mailbox=true won’t impose scheduling dependencies between its producer and consumer. It’s usually specified when producer and consumer are not the same epoch</li>
<li><b>reuse</b>: true/false, when the mailbox is true and you can further set the mailbox channel as a reuse mailbox channel. The packet in the reuse mailbox will be reused by the consumer if no new packet arrives from the producer side</li>
<li><b>fifo-size</b>: this is used to set the FIFO size of the channel, integer value, optional, default to 1 if not set</li>
<li><b>indirect</b>: true/false, if indirect is set to true, this means the downstream requires upstream data of previous frame</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="application-json"></a>
Application JSON</h2>
<ul>
<li><b>name</b>: application name</li>
<li><b>logSpec</b>: application log name</li>
<li><b>parameters</b>: application parameters</li>
<li><b>requiredSensors</b>: The required sensors JSON file</li>
<li><b>subcomponents</b>: The subcomponents (same as for graphlets).</li>
<li><b>connections</b>: The connections (same as for graphlets).</li>
<li><b>states</b>: Commonly a single default state which maps to the STM schedule.</li>
<li><b>stmSchedules</b>: Scheduling information as described in the next subsection.</li>
<li><b>processes</b>: OS processes to be instantiated<ul>
<li><b>executable</b>: executable file</li>
<li><b>argv</b> command line arguments of the process, e.g. for the STM master process<ul>
<li><b>&ndash;log</b>: STM master log name</li>
<li><b>&ndash;soc</b>: Specifies which Tegra STM master runs on</li>
<li><b>-m</b>: true = no skip on hyperepoch overrun</li>
<li><b>-v</b>: verbose mode</li>
</ul>
</li>
<li><b>logSpec</b>: log of process</li>
<li><b>subcomponents</b>: list of subcomponents if the process is a LoaderLite</li>
</ul>
</li>
<li><b>extraInfo</b>: ExtraInfo JSON file</li>
</ul>
<h3><a class="anchor" id="schedule-configuration"></a>
Schedule Configuration</h3>
<ul>
<li><b>wcet</b>: Worst Case Execution Time (WCET) YAML file</li>
<li><b>hyperepochs</b>: A hyperepoch is a resource partition that runs a fixed configuration of epochs that share the resources in that partition. It is periodic in nature, and it respawns the contained epochs at the specified period<ul>
<li><b>period</b>: period of hyperepoch respawning epochs</li>
<li><b>epochs</b>: A periodic timebase which dictates the rate at which a sub-graph of passes is respawned. It is confined to the boundaries of the hyperepoch<ul>
<li><b>period</b>: The period specified for the epoch specifies the rate at which a frame of passes is spawned, up to the number of frames specified, in the hyperepochs period</li>
<li><b>frames</b>: Number of frames each epoch spawns in specified hyperepoch period. Period specifies the time each frame is separated apart</li>
<li><b>passes</b>: A pass is an atomic unit of work, generally work that can be encompassed by a single function running on a single engine. Passes can have dependencies on other passes</li>
</ul>
</li>
<li><b>resources</b>: Any hardware engine (e.g. CPU, GPU, etc) or software resource (e.g. CUDA streams, scheduling mutexes, etc.) shared by multiple passes that needs to be modeled by STM compiler</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="sensorlayout-json"></a>
SensorLayout JSON</h2>
<ul>
<li><b>sensor layout configuration</b></li>
</ul>
<h1><a class="anchor" id="steps-to-create-a-compute-graph-framework-application"></a>
Steps to create a compute graph framework application</h1>
<ol type="1">
<li>Describe node interfaces in JSON format (demo JSON files provided in directories <code>src/dwframework/dwnodes</code> as well as <code>src/cgf/nodes</code>)<ol type="a">
<li>External interface: input/output ports, parameters</li>
<li>Internal / scheduling interface: passes, meta data relevant for scheduling</li>
<li>Node description JSON files are included in directory <code>src/cgf/graphs/descriptions/nodes</code></li>
</ol>
</li>
<li>Describe graphlet interfaces in JSON format, composed of nodes and other graphlets (demo JSON files provided in directory <code>src/cgf/graphs/descriptions/graphlets</code>)<ol type="a">
<li>External interface: input/output ports, parameters</li>
<li>Internal / scheduling interface: nodes and nested graphlets</li>
<li>Graphlet description JSON files are included in directory src/cgf/graphs/descriptions/graphlets</li>
</ol>
</li>
<li>Describe complete compute graph in <code>CGFDemo.graphlet.json</code> (file provided in <code>src/cgf/graphs/descriptions/graphlets</code>) in JSON format which composed of nodes and graphlet</li>
<li>(Optional, but recommended) Visualize the nodes, graphlets, DAGs<ol type="a">
<li>Using the graphical editor to view the nodes/graphlets and their connections with <code>CGFDemo.graphlet.json</code></li>
<li>GUI tool release is included in a separate tar file. Please refer to README.md for usage information</li>
</ol>
</li>
<li>Describe the application specific metadata (e.g. parameters, epochs, hyperepochs) in JSON format<ol type="a">
<li>application description JSON files are included in directory: <code>src/cgf/graphs/descriptions/systems</code>. Please refer to previous section for these metadata descriptions</li>
</ol>
</li>
<li>(Optional) Adding a custom node to the demo<ol type="a">
<li><p class="startli">Using the provided tool in <code>tools/descriptionScheduleYamlGenerator</code>, convert application description JSON files into YAML file for STM compiler</p>
<p class="startli">command: <code>./descriptionScheduleYamlGenerator.py --graph CGFDemo.app.json --output CGFDemo.yaml</code></p>
</li>
<li><p class="startli">Using <code>stmcompiler</code> tool from STM package, <code>.stm</code> binary file can be generated with YAML input</p>
<p class="startli">command: <code>./stmcompiler -i CGFDemo.yaml -o GFDemo.stm</code></p>
</li>
<li>Performance fine tuning in the schedule table. Performance tuning and architecture analysis tools will be released in future release</li>
<li>If running with an added custom node, copy new STM, <code>CGFDemo.stm</code>, into <code>cgf/graphs</code> directory on DDPX. In addition, copy custom node directory and updated JSON files such as <code>CGFDemo.graphlet.json</code>, <code>CGFDemo.schedule.json</code> onto DDPX</li>
</ol>
</li>
<li>Once set up, demo can be launched with command <code>sudo ./run_cgf.sh</code></li>
</ol>
<p >Some demo components are released in binary form. Please refer to the description of each binary:</p>
<ul>
<li><b>launcher</b>: Launcher parses the application description, launch loader, STM master, SSM master</li>
<li><b>LoaderLite</b>: LoaderLite takes in the application descriptions, instantiates system-wide parameters and handles. It also instantiates the corresponding dwGraphlet, instantiates SSMClone and STM client, registers passes and enters them into scheduler</li>
<li><b>sensor_sync_server</b>: Sensor sync server</li>
<li><b>descriptionScheduleYamlGenerator</b>: A tool that converts application description files into YAML format for STM compilation</li>
<li><b>stm_master</b>: Precompiled STM (System Task Manager)</li>
<li><b>vanillassm</b>: Precompiled SSM (System State Manager)</li>
</ul>
<h1><a class="anchor" id="integrate-a-custom-node-json-into-the-application"></a>
Integrate a custom node JSON into the application</h1>
<p >With the node structure explained above, we can now create a custom node based on the HelloWorld and Sum sample code provided. Please follow the following steps to add the HelloWorld and Sum sample node into the demo compute graph:</p>
<ol type="1">
<li>Set up your cross compile environment for DriveWorks sample based on the DriveWorks SDK documentation</li>
<li>libcgf_custom_nodes.so will then be generated under build/src/cgf_node directory</li>
<li>Copy libcgf_custom_nodes.so into DDPX targets/linux-amd64-ubuntu/lib directory</li>
<li>Copy HelloWorldNode.node.json and SumNode.node.json into driveworks/src/cgf/nodes folder</li>
<li>In CGFDemo.graphlet.json, HelloWorld and Sum nodes can be added in these three sections:<ol type="a">
<li>Under subcomponents: <pre class="fragment">"helloworld": {
    "componentType": "../../../../../nodes/HelloWorldNode.node.json"
    "parameters": { "name": "$name" }
},
"sum": {
    "componentType": "../../../nodes/SumNode.node.json"
}
</pre></li>
<li>Under parameters, add HelloWorld name parameter: <pre class="fragment">"name": { "type": "std::string", "default": "Demo" }
</pre></li>
<li>Under connections <pre class="fragment">{ "src": "helloworld.VALUE_0", "dests": {"sum.VALUE_0": {}} },
{ "src": "helloworld.VALUE_1", "dests": {"sum.VALUE_1": {}} },
</pre></li>
</ol>
</li>
<li><p class="startli">In CGFDemo.app.json, add HelloWorld and Sum:</p>
<p class="startli">"renderEpoch": { "passes": [ ... "cgfDemo.arender", "cgfDemo.helloworld", "cgfDEmo.sum" ] }</p>
</li>
<li>To create new STM binary, let's first convert .app.json to yaml with descriptionScheduleYamlGenerator tool. Using descriptionScheduleYamlGenerator.py in tools folder, use command: <code>./descriptionScheduleYamlGenerator --graph CGFDemo.app.json --output CGFDemo.yaml</code></li>
<li>Now generate STM binary with stmcompiler tool. Using stmcompiler in the tools folder, use command: <code>./stmcompiler -i CGFDemo.yaml -o CGFDemo.stm</code></li>
<li>Replace with new CGFDemo.stm in src/cgf/graphs folder</li>
</ol>
<h1><a class="anchor" id="verify-the-functionality-of-custom-node"></a>
Verify the functionality of custom node</h1>
<p >To quickly verify if the node has been added into the framework successfully, prints can be added in the C++ implementation. This example can be found in the HelloWorld node. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
