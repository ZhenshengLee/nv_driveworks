////////////////////////////////////////////////////////////////////////////////
// This code contains NVIDIA Confidential Information and is disclosed
// under the Mutual Non-Disclosure Agreement.
//
// Notice
// ALL NVIDIA DESIGN SPECIFICATIONS AND CODE ("MATERIALS") ARE PROVIDED "AS IS"
// NVIDIA MAKES NO REPRESENTATIONS, WARRANTIES, EXPRESSED, IMPLIED, STATUTORY,
// OR OTHERWISE WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ANY
// IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// NVIDIA Corporation assumes no responsibility for the consequences of use of
// such information or for any infringement of patents or other rights of third
// parties that may result from its use. No license is granted by implication or
// otherwise under any patent or patent rights of NVIDIA Corporation. No third
// party distribution is allowed unless expressly authorized by NVIDIA.  Details
// are subject to change without notice. This code supersedes and replaces all
// information previously supplied. NVIDIA Corporation products are not
// authorized for use as critical components in life support devices or systems
// without express written approval of NVIDIA Corporation.
//
// Copyright (c) 2022 NVIDIA Corporation. All rights reserved.
//
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and any
// modifications thereto. Any use, reproduction, disclosure or distribution of
// this software and related documentation without an express license agreement
// from NVIDIA Corporation is strictly prohibited.
//
////////////////////////////////////////////////////////////////////////////////
#ifndef MATRIXTYPES_H_
#define MATRIXTYPES_H_
// Generated by dwProto from matrix_types.proto DO NOT EDIT BY HAND!
// See //3rdparty/shared/dwproto/README.md for more information

// RFD - MISRAC 2012 Rule 1.4: Using emergent head file (stdalign.h)
// coverity[misra_c_2012_rule_1_4_violation]
#include <stdalign.h>

#include "BasicTypes.h"

#ifdef __cplusplus
extern "C" {
#endif

/// @brief Defines a two-element single-precision floating-point vector.
//# sergen(generate)
typedef struct dwVector2f
{
    alignas(8) float32_t x;
    float32_t y;
} dwVector2f;

/// @brief Defines a two-element double-precision floating-point vector.
//# sergen(generate)
typedef struct dwVector2d
{
    alignas(16) float64_t x;
    float64_t y;
} dwVector2d;

/// @brief Defines a two-element integer vector.
typedef struct dwVector2i
{
    alignas(8) int32_t x;
    int32_t y;
} dwVector2i;

/// @brief Defines a two-element unsigned-integer vector.
typedef struct dwVector2ui
{
    alignas(8) uint32_t x;
    uint32_t y;
} dwVector2ui;

/// @brief Defines a three-element floating-point vector.
//# sergen(generate)
typedef struct dwVector3f
{
    float32_t x;
    float32_t y;
    float32_t z;
} dwVector3f;

/// @brief Defines a three-element double-precision floating point vector.
//# sergen(generate)
typedef struct dwVector3d
{
    float64_t x;
    float64_t y;
    float64_t z;
} dwVector3d;

/// @brief Defines a four-element single-precision floating point vector.
typedef struct dwVector4f
{
    alignas(16) float32_t x;
    float32_t y;
    float32_t z;
    float32_t w;
} dwVector4f;

/// @brief Defines a four-element double-precision floating point vector.
typedef struct dwVector4d
{
    alignas(16) float64_t x;
    float64_t y;
    float64_t z;
    float64_t w;
} dwVector4d;

/// @brief Defines a three-element unsigned-integer vector.
typedef struct dwVector3ui
{
    uint32_t x;
    uint32_t y;
    uint32_t z;
} dwVector3ui;

/// @brief Defines a four-element unsigned-integer vector.
typedef struct dwVector4ui
{
    alignas(16) uint32_t x;
    uint32_t y;
    uint32_t z;
    uint32_t w;
} dwVector4ui;

/// @brief Defines a 2x2 matrix of floating point numbers by using only one array.
/// To access an element of the matrix: item(row,col) = _array[row + col*2].
typedef struct dwMatrix2f
{
    alignas(16) float32_t array[4];
} dwMatrix2f;

/// @brief Defines a 3x3 matrix of floating point numbers by using only one array.
/// To access an element of the matrix: item(row,col) = _array[row + col*3].
typedef struct dwMatrix3f
{
    float32_t array[9];
} dwMatrix3f;

/// @brief Defines a 3x3 matrix of double floating point numbers by using only one array.
/// To access an element of the matrix: item(row,col) = _array[row + col*3].
typedef struct dwMatrix3d
{
    float64_t array[9];
} dwMatrix3d;

/// @brief Defines a 4x4 matrix of floating point numbers (column major) by using only one array.
/// To access an element of the matrix: item(row,col) = _array[row + col*4].
typedef struct dwMatrix4f
{
    alignas(16) float32_t array[16];
} dwMatrix4f;

/// @brief Defines a 3x4 matrix of floating point numbers (column major) by using only one array.
/// To access an element of the matrix: item(row,col) = _array[row + col*4].
typedef struct dwMatrix34f
{
    alignas(16) float32_t array[12];
} dwMatrix34f;

/// @brief Defines a 6x6 matrix of floating point numbers (column major) by using only one array.
/// To access an element of the matrix: item(row,col) = _array[row + col*6].
typedef struct dwMatrix6f
{
    alignas(16) float32_t array[36];
} dwMatrix6f;

/// @brief Specifies a 2D transformation as a 3 x 3 matrix in column-major order.
/// The top left 2 x 2 represents rotation and scaling, the right column is the translation.
/// The bottom row is expected to be [0 0 1]
/// To access an element of the matrix: item(row,col) = _array[row + col*3].
typedef struct dwTransformation2f
{
    float32_t array[9];
} dwTransformation2f;

/// @brief Specifies a 3D rigid transformation.
/// The transformation is a 4x4 matrix in column-major order.
/// The top left 3x3 represents rotation, and the right column is the translation.
/// The bottom row is expected to be [0 0 0 1]
/// To access an element of the matrix: item(row,col) = _array[row + col*4].
typedef struct dwTransformation3f
{
    alignas(16) float32_t array[16]; //!< 3D rigid transformation array
} dwTransformation3f;

/// @brief Confidence structure with variance of inliers.
///
/// Our strategy for uncertainty representation is to give classification confidence scalars for
/// classifications and confidence intervals and covariance for coordinate estimates.
/// The classification confidence scalars are straightforward, a scalar in the [0,1] interval.
/// For obstacles, lanes and lane edges we give the main classification confidence and also a sub-classification confidence.
/// This is to provide access to good information for major classes that matter and also for detailed sub-classification.
///
/// For coordinates and other values we provide confidence and covariance which allow us to handle both outliers
/// (the small but non-zero number of cases where estimates are very wrong) and the properties of the inlier distribution.
/// We essentially provide the covariance matrix of the inlier distribution and the confidence and corresponding scaling of
/// the confidence ellipsoid. This allows to easily test whether any new value belong to the confidence interval
/// for example by checking that x' (covariance)^-1 x <= threshold'. The confidence (inlier ratio) in this case represents
/// the amount of inliers within this threshold.
typedef struct dwConfidence1f
{
    float32_t confidence; //!< Inlier ratio [0,1]
    float32_t threshold;  //!< Inlier threshold
    float32_t variance;   //!< Variance of inliers
} dwConfidence1f;

/// @brief Confidence structure with 2x2 covariance matrix.
/// Refer to dwConfidence1f for more details
typedef struct dwConfidence2f
{
    float32_t confidence;
    float32_t threshold;
    dwMatrix2f covariance;
} dwConfidence2f;

/// @brief Confidence structure with 3x3 covariance matrix.
/// Refer to dwConfidence1f for more details
typedef struct dwConfidence3f
{
    float32_t confidence;
    float32_t threshold;
    dwMatrix3f covariance;
} dwConfidence3f;

#ifdef __cplusplus
}
#endif

#endif // MATRIXTYPES_H_
